

<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>まずは始めてみよう &mdash; Proof-Oriented Programming in F*  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=24463673" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c033477b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=4755f45a"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="多相と型推論" href="part1_polymorphism.html" />
    <link rel="prev" title="全域関数によるプログラミングと証明" href="part1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Proof-Oriented Programming in F*
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../structure.html">本書の構成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">イントロダクション</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part1.html">全域関数によるプログラミングと証明</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">まずは始めてみよう</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#text-editors">テキストエディタ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-syntactic-structure">基本的な構文構造</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comments">コメント</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primitives">プリミティブ</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#false">False</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit">Unit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booleans">ブール値</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integers">整数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-refinement-types">ブール精錬（リファインメント）型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#refinement-subtyping">精錬のサブタイピング</a></li>
<li class="toctree-l4"><a class="reference internal" href="#an-example">例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions">関数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lambda-terms">ラムダ項</a></li>
<li class="toctree-l4"><a class="reference internal" href="#named-functions">名前付き関数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursive-functions">再帰関数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#arrow-types">矢印（関数）型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#some-examples-and-common-notation">いくつかの例と慣用表記</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">練習問題</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#many-types-for-incr"><code class="docutils literal notranslate"><span class="pre">incr</span></code> に与えられる多様な型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#computing-the-maximum-of-two-integers">2 つの整数の最大値を計算する</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-types-for-factorial">factorial に与えられる別の型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fibonacci">フィボナッチ</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="part1_polymorphism.html">多相と型推論</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_equality.html">等値性（Equality）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_prop_assertions.html">SMT ソルバとの連携</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_inductives.html">帰納的データ型とパターンマッチ</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_termination.html">停止性の証明</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_lemmas.html">補題と帰納法による証明</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_quicksort.html">ケーススタディ：クイックソート</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_execution.html">プログラムの実行</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_wrap.html">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part2/part2.html">帰納的型によるデータ・証明・計算の表現</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part3/part3.html">インターフェースと型クラスによるモジュール性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part4/part4.html">計算効果</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part5/part5.html">Meta-F* によるタクティクスとメタプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/pulse.html">Pulse: 並行分離論理における証明指向プログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../under_the_hood/under_the_hood.html">内部の仕組み</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part1.html">全域関数によるプログラミングと証明</a></li>
      <li class="breadcrumb-item active">まずは始めてみよう</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <section id="getting-off-the-ground">
<span id="part1-ch1"></span><h1>まずは始めてみよう<a class="headerlink" href="#getting-off-the-ground" title="Link to this heading"></a></h1>
<p>F* でプログラムを書き始めるには、言語の文法の基礎と、型と関数に関する中核的な概念を少し学ぶ必要があります。</p>
<section id="text-editors">
<span id="part1-editors"></span><h2>テキストエディタ<a class="headerlink" href="#text-editors" title="Link to this heading"></a></h2>
<p>F* はコマンドラインツールとして、任意のテキストエディタと組み合わせて利用できます。このインタラクティブなオンラインチュートリアルを見ている場合は、構文ハイライトなどの基本機能を備えた <a class="reference external" href="https://ace.c9.io/">Ace ベース</a> のエディタも併用できます。ただし軽い用途を超えると、多くの F* ユーザーは次のいずれかの IDE プラグインを利用しています。</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/FStarLang/fstar-mode.el">fstar-mode.el</a>：Emacs 上で F* ファイルを対話的に編集・チェックするための各種ユーティリティを提供します。</p></li>
<li><p><a class="reference external" href="https://github.com/FStarLang/fstar-vscode-assistant">fstar-vscode-assistant</a>：VS Code での対話的な編集とチェックをサポートします。</p></li>
</ul>
</div></blockquote>
<p>これらの IDE プラグインを使う主な利点は、ファイル全体をバッチ的に再チェックするのではなく、変更された末尾部分だけを段階的に検査できる点です。また、定義へのジャンプやシンボルの型表示といった標準的な機能も提供します。</p>
<p>両プラグインは、F* コンパイラが実装する汎用だが独自の対話プロトコルに基づいています。同様の仕組みを用いて、好みのプラグイン対応エディタに fstar-mode.el や fstar-vscode-assistant に近い IDE サポートを実装することも可能です。</p>
</section>
<section id="basic-syntactic-structure">
<h2>基本的な構文構造<a class="headerlink" href="#basic-syntactic-structure" title="Link to this heading"></a></h2>
<p>F* のプログラムはモジュールの集合で構成され、各モジュールは拡張子 <code class="docutils literal notranslate"><span class="pre">.fst</span></code> の単一ファイルで表されます。後で述べるように、モジュールのインターフェイスは別の <code class="docutils literal notranslate"><span class="pre">.fsti</span></code> ファイルに置かれ、クライアント側から実装の詳細を隠蔽できます。</p>
<p>モジュールはその名前（ファイル名と一致していなければなりません。たとえば <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">A</span></code> は <code class="docutils literal notranslate"><span class="pre">A.fst</span></code>）で始まり、トップレベルのシグネチャと定義の並びを含みます。モジュール名は常に大文字で始まります。</p>
<ul class="simple">
<li><p>シグネチャは定義に型を与えます（例：<code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">f</span> <span class="pre">:</span> <span class="pre">t</span></code>）。</p></li>
</ul>
<p>定義にはいくつかの種類がありますが、全域関数でのプログラミングで主に扱うのは次の 2 つです。</p>
<ul class="simple">
<li><p>再帰の可能な定義（let 束縛、<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">[rec]</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">e</span></code>）</p></li>
<li><p>帰納的な型定義（データ型、<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">D1</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">|</span> <span class="pre">...</span> <span class="pre">|</span> <span class="pre">Dn</span> <span class="pre">:</span> <span class="pre">tn</span></code>）</p></li>
</ul>
<p>後の節では、ユーザー定義のインデックス付きエフェクトとサブエフェクトという 2 種類の定義も扱います。</p>
</section>
<section id="comments">
<h2>コメント<a class="headerlink" href="#comments" title="Link to this heading"></a></h2>
<p>ブロックコメントは <code class="docutils literal notranslate"><span class="pre">(*</span></code> と <code class="docutils literal notranslate"><span class="pre">*)</span></code> で囲みます。行コメントは <code class="docutils literal notranslate"><span class="pre">//</span></code> で始めます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="c">(* this is a</span>
<span class="c">   block comment *)</span>


<span class="c">//This is a line comment</span>
</pre></div>
</div>
</section>
<section id="primitives">
<h2>プリミティブ<a class="headerlink" href="#primitives" title="Link to this heading"></a></h2>
<p>すべての F* プログラムは、F* の中核モジュール <code class="docutils literal notranslate"><span class="pre">Prims</span></code> が提供する基本定義の文脈で検査されます。</p>
<section id="false">
<h3>False<a class="headerlink" href="#false" title="Link to this heading"></a></h3>
<p>型 <code class="docutils literal notranslate"><span class="pre">False</span></code> には要素がありません。<code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">False</span></code> を満たす項は存在しないため、<code class="docutils literal notranslate"><span class="pre">False</span></code> は証明不可能な命題の型です。</p>
</section>
<section id="unit">
<h3>Unit<a class="headerlink" href="#unit" title="Link to this heading"></a></h3>
<p>型 <code class="docutils literal notranslate"><span class="pre">unit</span></code> には <code class="docutils literal notranslate"><span class="pre">()</span></code> という 1 つの要素だけがあります（<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">:</span> <span class="pre">unit</span></code>）。</p>
</section>
<section id="booleans">
<h3>ブール値<a class="headerlink" href="#booleans" title="Link to this heading"></a></h3>
<p>型 <code class="docutils literal notranslate"><span class="pre">bool</span></code> には <code class="docutils literal notranslate"><span class="pre">true</span></code> と <code class="docutils literal notranslate"><span class="pre">false</span></code> の 2 つの要素があります。小文字の <code class="docutils literal notranslate"><span class="pre">false</span></code> はブール定数であり、大文字の型 <code class="docutils literal notranslate"><span class="pre">False</span></code> とは別物である点に注意してください。</p>
<p>以下のプリミティブなブール演算子が利用できます（優先順位の高い順）。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">not</span></code>：論理否定（単項・前置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>：論理積（2 項・中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">||</span></code>：論理和（2 項・中置）</p></li>
</ul>
<section id="conditionals">
<h4>条件式<a class="headerlink" href="#conditionals" title="Link to this heading"></a></h4>
<p>もちろん、<code class="docutils literal notranslate"><span class="pre">if/then/else</span></code> でブール値に基づく分岐が行えます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> b <span class="k">then</span> 1 <span class="k">else</span> 0

<span class="k">if</span> b1 &amp;&amp; b2 || b3
<span class="k">then</span> 17
<span class="k">else</span> 42
</pre></div>
</div>
</section>
</section>
<section id="integers">
<h3>整数<a class="headerlink" href="#integers" title="Link to this heading"></a></h3>
<p>型 <code class="docutils literal notranslate"><span class="pre">int</span></code> は上限のない（任意精度の）数学的な整数を表します。要素は <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span></code> といったリテラルおよび、以下のプリミティブ演算子（優先順位の高い順）で構成されます。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code>：単項の符号反転（前置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code>：減算（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code>：加算（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/</span></code>：ユークリッド除算（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%</span></code>：ユークリッド剰余（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">op_Multiply</span></code>：残念ながら、従来の乗算記号 <code class="docutils literal notranslate"><span class="pre">*</span></code> は既定ではタプル型コンストラクタに予約されています。整数の乗算として <code class="docutils literal notranslate"><span class="pre">*</span></code> を使うには <code class="docutils literal notranslate"><span class="pre">FStar.Mul</span></code> モジュールを利用してください。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code>：より小さい（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>：以下（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code>：より大きい（中置）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>：以上（中置）</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>F* は OCaml にならい、負の整数リテラルを持ちません。正の整数に符号反転を適用し、<code class="docutils literal notranslate"><span class="pre">(-</span> <span class="pre">1)</span></code> のように書きます。</p>
</div>
</section>
</section>
<section id="boolean-refinement-types">
<span id="part1-ch1-boolean-refinements"></span><h2>ブール精錬（リファインメント）型<a class="headerlink" href="#boolean-refinement-types" title="Link to this heading"></a></h2>
<p>F* のコアライブラリ <code class="docutils literal notranslate"><span class="pre">Prims</span></code> は、自然数型を次のように定義しています。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> nat = x:int{x &gt;= 0}
</pre></div>
</div>
<p>これはブール精錬型の一例です。一般形は <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">e</span> <span class="pre">}</span></code> で、<code class="docutils literal notranslate"><span class="pre">t</span></code> は型、<code class="docutils literal notranslate"><span class="pre">e</span></code> は <code class="docutils literal notranslate"><span class="pre">t</span></code> 型の束縛変数 <code class="docutils literal notranslate"><span class="pre">x</span></code> を参照しうる <code class="docutils literal notranslate"><span class="pre">bool</span></code> 型の項です。<code class="docutils literal notranslate"><span class="pre">e</span></code> は、<code class="docutils literal notranslate"><span class="pre">t</span></code> が表す集合 <code class="docutils literal notranslate"><span class="pre">S</span></code> を <code class="docutils literal notranslate"><span class="pre">e</span></code> が <code class="docutils literal notranslate"><span class="pre">true</span></code> に評価される要素 <code class="docutils literal notranslate"><span class="pre">x</span></code> に限定するという意味で、型 <code class="docutils literal notranslate"><span class="pre">t</span></code> を <em>精錬（refine）</em> します。</p>
<p>つまり、型 <code class="docutils literal notranslate"><span class="pre">nat</span></code> は <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">...}</span></code> の要素に評価される項の集合を記述します。</p>
<p>とはいえ <code class="docutils literal notranslate"><span class="pre">nat</span></code> が特別というわけではありません。例えば次のように、任意の条件で自由に精錬型を定義できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> empty = x:int { <span class="k">false</span> } <span class="c">//the empty set</span>
<span class="k">let</span> zero = x:int{ x = 0 } <span class="c">//the type containing one element `0`</span>
<span class="k">let</span> pos = x:int { x &gt; 0 } <span class="c">//the positive numbers</span>
<span class="k">let</span> neg = x:int { x &lt; 0 } <span class="c">//the negative numbers</span>
<span class="k">let</span> even = x:int { x % 2 = 0 } <span class="c">//the even numbers</span>
<span class="k">let</span> odd = x:int { x % 2 = 1 } <span class="c">//the odd numbers</span>
</pre></div>
</div>
<p>C や Java のように、型が主としてメモリ上の表現特性を表す言語に慣れていると、“任意の値集合を記述するものとしての型”という見方はやや異質に感じられるかもしれません。しかし、この発想に慣れると、値集合を精密に切り出す型によって、コードの中では暗黙に過ぎなかった不変条件を明示し、検査できるようになります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>F* の精錬型は、2007〜2011 年に Microsoft Research で開発された言語 <a class="reference external" href="https://www.microsoft.com/en-us/research/project/f7-refinement-types-for-f/">F7</a> に源流があります。<a class="reference external" href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Liquid Haskell</a> も精錬型を備えた言語です。これらの言語は、精錬型を学ぶための背景知識や資料を提供してくれます。</p>
<p>ブール精錬は、F* におけるより強力な命題的精錬型の特別な場合です。精錬型は依存関数型と組み合わせることで、原理的には多様なプログラム正当性の論理を表現できます。とはいえ、精錬型は F* における仕様記述と証明のための道具の一つに過ぎません。</p>
</div>
<section id="refinement-subtyping">
<h3>精錬のサブタイピング<a class="headerlink" href="#refinement-subtyping" title="Link to this heading"></a></h3>
<p>ここまでに <code class="docutils literal notranslate"><span class="pre">nat</span></code> や <code class="docutils literal notranslate"><span class="pre">even</span></code> のような新しい精錬型の定義方法を見てきました。しかし精錬型を実際に活用するには、次を可能にする規則が必要です。</p>
<ol class="arabic simple">
<li><p>あるプログラム項が与えられた精錬型をもつことを検査する（例：<code class="docutils literal notranslate"><span class="pre">0</span></code> が <code class="docutils literal notranslate"><span class="pre">nat</span></code> 型であることを確かめる）。これは精錬型の <em>導入</em> と呼ばれます。</p></li>
<li><p>精錬型をもつ項を利用する（例：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">even</span></code> が与えられたとき、<code class="docutils literal notranslate"><span class="pre">x</span></code> を <code class="docutils literal notranslate"><span class="pre">int</span></code> として扱って <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> と書ける）。これは精錬型の <em>除去</em> と呼ばれます。</p></li>
</ol>
<p>F* でこれら両方を支える技術的仕組みが <em>精錬のサブタイピング</em> です。</p>
<p>Java や C# などのオブジェクト指向言語に慣れていれば、サブタイプという概念はおなじみでしょう。型 <code class="docutils literal notranslate"><span class="pre">t</span></code> の項を安全に <code class="docutils literal notranslate"><span class="pre">s</span></code> として扱えるとき、<code class="docutils literal notranslate"><span class="pre">t</span></code> は <code class="docutils literal notranslate"><span class="pre">s</span></code> のサブタイプです。たとえば Java では、すべてのオブジェクト型は基底クラス <code class="docutils literal notranslate"><span class="pre">Object</span></code> のサブタイプです。</p>
<p>ブール精錬型に関するサブタイピング規則は次のとおりです。</p>
<ul class="simple">
<li><p>型 <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">}</span></code> は <code class="docutils literal notranslate"><span class="pre">t</span></code> のサブタイプです。すなわち <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">(x:t{p})</span></code> なら、精錬を <em>除去</em> して <code class="docutils literal notranslate"><span class="pre">e</span></code> を <code class="docutils literal notranslate"><span class="pre">t</span></code> 型として扱ってよいことが常に保証されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> 型の項 <code class="docutils literal notranslate"><span class="pre">e``（すなわち</span> <span class="pre">``e</span> <span class="pre">:</span> <span class="pre">t</span></code>）に対して、<code class="docutils literal notranslate"><span class="pre">p[e/x]``（``p</span></code> の変数 <code class="docutils literal notranslate"><span class="pre">x</span></code> を <code class="docutils literal notranslate"><span class="pre">e</span></code> に置換した項）が``true`` であることを証明できるとき、<code class="docutils literal notranslate"><span class="pre">t</span></code> はブール精錬型 <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">}</span></code> のサブタイプです。言い換えれば、<code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> において <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code> を <em>導入</em> するには、束縛変数 <code class="docutils literal notranslate"><span class="pre">x</span></code> を <code class="docutils literal notranslate"><span class="pre">e</span></code> に置き換えた <code class="docutils literal notranslate"><span class="pre">p</span></code> が``true`` に評価されることを示せば十分です。</p></li>
</ul>
<p>精錬型の除去規則（上の最初の項目）は単純です。型を集合とみなす直観に従えば、精錬型 <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> は述語 <code class="docutils literal notranslate"><span class="pre">p</span></code> によって <code class="docutils literal notranslate"><span class="pre">t</span></code> に対応する集合を <em>精錬</em> した部分集合を表します。したがって、<code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> が <code class="docutils literal notranslate"><span class="pre">t</span></code> のサブタイプであるのは当然です。</p>
<p>逆方向は少し繊細です。<code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> がサブタイプになるのは、<code class="docutils literal notranslate"><span class="pre">p</span></code> を満たす項 <code class="docutils literal notranslate"><span class="pre">e</span></code> に対してのみです。<code class="docutils literal notranslate"><span class="pre">p[e/x]</span></code> が <code class="docutils literal notranslate"><span class="pre">true</span></code> に評価されることをどう証明するのか、という点も気になるでしょう。詳細は後述しますが、要するに F* は既定で SMT ソルバを用いてこの種の事実を証明します（タクティクス等を使うことも可能です）。</p>
</section>
<section id="an-example">
<h3>例<a class="headerlink" href="#an-example" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">x:even</span></code> が与えられたとき、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code> を示すにはいくつかの段階があります。</p>
<ol class="arabic simple">
<li><p>演算子 <code class="docutils literal notranslate"><span class="pre">+</span></code> は F* のライブラリで定義されています。引数はいずれも <code class="docutils literal notranslate"><span class="pre">int</span></code> 型で、結果も <code class="docutils literal notranslate"><span class="pre">int</span></code> です。</p></li>
<li><p>第 1 引数 <code class="docutils literal notranslate"><span class="pre">x:even</span></code> が <code class="docutils literal notranslate"><span class="pre">+</span></code> の引数として妥当であることを示すには、精錬のサブタイピングで精錬を除去し <code class="docutils literal notranslate"><span class="pre">x:int</span></code> を得ます。第 2 引数 <code class="docutils literal notranslate"><span class="pre">1:int</span></code> はすでに期待された型です。したがって <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">int</span></code> となります。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code> と結論づけるには、<code class="docutils literal notranslate"><span class="pre">odd</span></code> の精錬述語が真になる（すなわち <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">1</span></code>）ことを示して精錬型を導入する必要があります。<code class="docutils literal notranslate"><span class="pre">x</span></code> が偶数であるという前提があるため、これは SMT により証明可能です。</p></li>
</ol>
<p>このように、F* は精錬型の導入・除去のためにサブタイピングを繰り返し適用します。<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code> のような単純な式の検査でも、複数回適用されることがあります。</p>
</section>
</section>
<section id="functions">
<h2>関数<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<p>興味深いプログラムを書くには、まず関数を定義する方法が必要です。F* の核にある関数は数学における関数のように振る舞います。つまり、定義域全体で定義され（全域関数で常に結果を返し）、観測可能な挙動は返り値だけです（無限ループやメッセージの出力などの副作用はありません）。</p>
<p>F* では関数は第一級の値であり、他の関数への引数として渡したり、結果として返したりできます。関数の定義方法はいくつかありますが、最も基本的な形は <span class="math notranslate nohighlight">\(\lambda\)</span> 項（関数リテラル、無名関数、<em>ラムダ</em>）です。文法は主に OCaml から受け継いでおり、未経験の方は <a class="reference external" href="https://ocaml.org/docs/tour-of-ocaml#functions">OCaml のチュートリアル</a> が詳しい参考になります。以下では OCaml 風の構文にある程度慣れていることを前提とします。</p>
<section id="lambda-terms">
<h3>ラムダ項<a class="headerlink" href="#lambda-terms" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">(x:int)</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> は、整数型の引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> に 1 を加える関数（ラムダ項）を定義します。引数の型は F* に推論させ、<code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> と書くこともできます。</p>
</section>
<section id="named-functions">
<span id="part1-ch1-named-function"></span><h3>名前付き関数<a class="headerlink" href="#named-functions" title="Link to this heading"></a></h3>
<p>F* では任意の項に <code class="docutils literal notranslate"><span class="pre">let</span></code> 束縛で名前を付けられます。関数を 1 度定義して何度も呼び出すために使います。たとえば次のいずれも同義で、ラムダ項 <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> に <code class="docutils literal notranslate"><span class="pre">incr</span></code> という名前を束縛します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr = <span class="k">fun</span> (x:int) -&gt; x + 1
<span class="k">let</span> incr (x:int) = x + 1
<span class="k">let</span> incr x = x + 1
</pre></div>
</div>
<p>関数は複数の引数を取ることができ、必要に応じて戻り値の型にも注釈を付けられます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr (x:int) : int = x + 1
<span class="k">let</span> more_than_twice (x:int) (y:int) : bool = x &gt; y + y
</pre></div>
</div>
<p>名前付き関数の定義では、すべての仮引数と戻り値の型に注釈を付けるのが望ましい作法とされています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>引数や戻り値の型注釈に加えて、F* では任意の項 <code class="docutils literal notranslate"><span class="pre">e</span></code> に対し <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&lt;:</span> <span class="pre">t</span></code> と書くことで期待される型 <code class="docutils literal notranslate"><span class="pre">t</span></code> を与えられます。これは <em>type ascription*（型アサーション／型注釈）と呼ばれ、項 ``e`` が型 ``t`` をもつことを F</em> に検査させます。例えば、次のようにも書けます。</p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr = <span class="k">fun</span> (x:int) -&gt; (x + 1 &lt;: int)
</pre></div>
</div>
</section>
<section id="recursive-functions">
<h3>再帰関数<a class="headerlink" href="#recursive-functions" title="Link to this heading"></a></h3>
<p>F* の再帰関数は常に名前付きです。定義には以下のように <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code> 構文を用います。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> FStar.Mul
<span class="k">let</span> <span class="k">rec</span> factorial (n:nat)
  : nat
  = <span class="k">if</span> n = 0
    <span class="k">then</span> 1
    <span class="k">else</span> n * factorial (n - 1)
</pre></div>
</div>
<p>この構文は、単一の引数 <code class="docutils literal notranslate"><span class="pre">n:nat</span></code> を取り <code class="docutils literal notranslate"><span class="pre">nat</span></code> を返す関数 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> を定義します。定義の中で <code class="docutils literal notranslate"><span class="pre">factorial</span></code> を再帰的に呼び出すことができます。後の章で述べるように、再帰が整礎的（すなわちすべての再帰呼び出しが停止する）であることを保証するのが F* の健全性の要です。ただし、この例では停止性の証明は自動で行われます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>上の例で <cite>open FStar.Mul</cite> を使っている点に注意してください。これにより <cite>FStar.Mul</cite> モジュールがスコープに入り、記号 <code class="docutils literal notranslate"><span class="pre">*</span></code> が整数の乗算として解決されます。</p>
</div>
<p>F* は相互再帰もサポートします。これは後ほど扱います。</p>
</section>
</section>
<section id="arrow-types">
<span id="part1-ch1-arrows"></span><h2>矢印（関数）型<a class="headerlink" href="#arrow-types" title="Link to this heading"></a></h2>
<p>関数は関数型言語の主要な抽象化手段であり、その型は F* 全体にわたって現れます。最も基本的な形の関数型（矢印型）は次の形をしています。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span><span class="n">t0</span> <span class="o">-&gt;</span> <span class="n">t1</span>
</pre></div>
</div>
<p>これは次の性質をもつ関数の型です。</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t0</span></code> 型の引数 <code class="docutils literal notranslate"><span class="pre">e</span></code> を受け取り、</p></li>
<li><p>常に <code class="docutils literal notranslate"><span class="pre">t1[e</span> <span class="pre">/</span> <span class="pre">x]</span></code> 型の値を返します。すなわち、戻り値の型が引数 <code class="docutils literal notranslate"><span class="pre">e</span></code> に依存します。</p></li>
</ol>
<p>この点が他言語の関数型とどのように異なるかを強調しておきましょう。</p>
<ul class="simple">
<li><p>F* の矢印は依存的で、結果の型が引数に依存します。例えば、偶数に適用すると <code class="docutils literal notranslate"><span class="pre">bool</span></code> を返し、奇数に適用すると <code class="docutils literal notranslate"><span class="pre">string</span></code> を返す関数を書くことができます。あるいは、より一般的には、結果が引数より 1 大きいことを型で表す関数が書けます。</p></li>
<li><p>F* のコア言語では、すべての関数は全域です。すなわち、関数呼び出しは有限（ただし上限は定めない）だけの資源を消費したのち、必ず停止します。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>とはいえ、実際の計算機上では、メモリ不足など資源枯渇により関数呼び出しが返らないことはありえます。後で <a class="reference internal" href="../structure.html#effects"><span class="std std-ref">effects</span></a> を扱う際に、F* が非停止関数の記述もサポートしていることを見ます。</p>
</div>
<section id="some-examples-and-common-notation">
<span id="part1-ch1-arrow-notations"></span><h3>いくつかの例と慣用表記<a class="headerlink" href="#some-examples-and-common-notation" title="Link to this heading"></a></h3>
<ol class="arabic">
<li><p>関数は <em>カリー化</em> されています。複数引数の関数は、最初の引数を取り、次の引数を取る関数を返す……という形で表されます。例えば整数加算の型は次のとおりです。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>すべての関数が依存的というわけではなく、引数名が不要な場合は省略できます。例えば <code class="docutils literal notranslate"><span class="pre">(+)</span></code> の型は次のように簡潔に書けます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>関数型は精錬型と組み合わせられます。例えば整数除算の型は次のように表せます。— 除数への精錬により 0 除算を禁止しています。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">/</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">divisor</span><span class="p">:</span><span class="nb">int</span> <span class="p">{</span> <span class="n">divisor</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>引数と戻り値の型の依存関係を用いて、両者の関係を型に表せます。例えば <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">incr</span> <span class="pre">=</span> <span class="pre">(fun</span> <span class="pre">(x:int)</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1)</span></code> という関数には次のようないくつかの型が与えられます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
<span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">}</span>
<span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
<p>最初の <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> は OCaml などで見られる伝統的な型です。</p>
<p>2 つ目の型 <code class="docutils literal notranslate"><span class="pre">x:int</span> <span class="pre">-&gt;</span> <span class="pre">y:int{y</span> <span class="pre">&gt;</span> <span class="pre">x}</span></code> は、戻り値 <code class="docutils literal notranslate"><span class="pre">y</span></code> が引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> より大きいことを述べています。</p>
<p>3 つ目の型が最も精密で、<code class="docutils literal notranslate"><span class="pre">x:int</span> <span class="pre">-&gt;</span> <span class="pre">y:int{y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1}</span></code> は結果 <code class="docutils literal notranslate"><span class="pre">y</span></code> が引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> をちょうど 1 増やしたものであることを述べます。</p>
</li>
<li><p>依存関数型では、引数側に精錬を加えると便利なことがよくあります。例えば次のように書けます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>
</pre></div>
</div>
<p>この書き方はきわめて一般的で、仮引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> に 2 回名前を束縛するのは不便なため、F* では次のように書くことが（むしろ推奨されて）可能です。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>F* のコアにおける関数が全域（すなわち必ず結果を返す）であることを強調するため、戻り値の型に効果ラベル「<code class="docutils literal notranslate"><span class="pre">Tot</span></code>」を付けることがあります。このラベルは任意ですが、特に <a class="reference internal" href="../structure.html#effects"><span class="std std-ref">effects</span></a> を学ぶ段になって、副作用のない関数であることを <code class="docutils literal notranslate"><span class="pre">Tot</span></code> で明示するのは有用です。例えば次のように書く場合があります。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">})</span>
</pre></div>
</div>
<p>最後の矢印に <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 注釈を付け、関数に副作用がないことを示しています。次のように書くこともできます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}))</span>
</pre></div>
</div>
<p>中間の矢印に注釈を付けていますが、これは一般的な書き方ではありません。</p>
</li>
</ol>
</section>
</section>
<section id="exercises">
<h2>練習問題<a class="headerlink" href="#exercises" title="Link to this heading"></a></h2>
<p>最初の例は、ツールの実行方法と出力の読み方を示すためのものです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> Part1.GettingOffTheGround

<span class="k">let</span> incr (x:int) : int = x + 1
</pre></div>
</div>
<p>プログラムは <code class="docutils literal notranslate"><span class="pre">module</span></code> 宣言で始まる点に注意してください。ここには <code class="docutils literal notranslate"><span class="pre">incr</span></code> という 1 つの定義だけが含まれています。モジュールのスコープ直下に現れる定義は「トップレベル定義」と呼ばれます。</p>
<p>これらの例を試す方法はいくつかあります。</p>
<p><strong>F* オンライン</strong></p>
<p>手早く始めたり小さな練習問題を試したりするには、<a class="reference external" href="http://fstar-lang.org/tutorial">オンラインチュートリアル</a> を使うのが最も簡単です。もし今そこで本文を読んでいるなら、クラウド上で動作する F* と連携するブラウザ内エディタをそのまま使えます。エディタに練習用コードを読み込むには、<a class="reference external" href="../code/exercises/Part1.GettingOffTheGround.fst">このリンク</a> をクリックしてください。</p>
<p>ただし、オンライン実行はサーバーの負荷によってはやや遅くなることがあり、エディタも最小限の機能にとどまります。</p>
<p>小さな練習を超える用途では、次節で述べるとおり、F* ツールチェーンをローカルにインストールして使うことを推奨します。</p>
<p><strong>F* のバッチ実行</strong></p>
<p>事前ビルド済みの F* バイナリは <a class="reference external" href="https://github.com/FStarLang/FStar/releases">こちら</a> から入手できます。</p>
<p>ローカルにインストールしたら、プログラムの検査はコマンドラインで <code class="docutils literal notranslate"><span class="pre">fstar</span></code> を実行して行えます。例えば次のようにします。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ fstar Sample.fst
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fstar</span></code> は次のような出力を返します。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Verified</span> <span class="n">module</span><span class="p">:</span> <span class="n">Sample</span>
<span class="n">All</span> <span class="n">verification</span> <span class="n">conditions</span> <span class="n">discharged</span> <span class="n">successfully</span>
</pre></div>
</div>
<p>これは、F* が <code class="docutils literal notranslate"><span class="pre">Sample</span></code> というモジュールの検証を試みたことを意味します。その際、型の正当性を示すために必要な「検証条件（verification conditions）」すなわち証明義務を生成し、それらをすべて解消（証明）できたことを表します。</p>
<p><strong>Emacs での F*</strong></p>
<p>コマンドラインから <code class="docutils literal notranslate"><span class="pre">fstar</span></code> をバッチ実行する代わりに、<a class="reference external" href="https://www.gnu.org/software/emacs/">emacs</a> を使う F* プログラマは、<a class="reference external" href="https://github.com/FStarLang/fstar-mode.el">fstar-mode.el</a> をよく用います。これは F* プログラムを対話的に検査できるエディタ用プラグインです。F* を本格的に使う予定があるなら強く推奨します。</p>
<section id="many-types-for-incr">
<h3><code class="docutils literal notranslate"><span class="pre">incr</span></code> に与えられる多様な型<a class="headerlink" href="#many-types-for-incr" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">incr</span></code> に与えられるいくつかの型例を示します。有効なものと無効なものが混ざっています。</p>
<p>この型は、<code class="docutils literal notranslate"><span class="pre">incr</span></code> の結果が引数より大きいと主張しており、F* もそれを認めます。<code class="docutils literal notranslate"><span class="pre">int</span></code> は無限精度であることを思い出してください。加算がオーバーフローする危険はありません。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr1 (x:int) : y:int{y &gt; x} = x + 1
</pre></div>
</div>
<p>この型は、<code class="docutils literal notranslate"><span class="pre">incr</span></code> が常に自然数を返すと主張していますが、これは正しくありません。負の数を 1 増やしても、必ず非負になるとは限らないからです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr2 (x:int) : nat = x + 1
</pre></div>
</div>
<p>F* は次のようなエラーメッセージを出力します。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sample</span><span class="o">.</span><span class="n">fst</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">26</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">31</span><span class="p">):</span> <span class="p">(</span><span class="n">Error</span> <span class="mi">19</span><span class="p">)</span> <span class="n">Subtyping</span> <span class="n">check</span> <span class="n">failed</span><span class="p">;</span> <span class="n">expected</span> <span class="nb">type</span>
<span class="n">Prims</span><span class="o">.</span><span class="n">nat</span><span class="p">;</span> <span class="n">got</span> <span class="nb">type</span> <span class="n">Prims</span><span class="o">.</span><span class="n">int</span><span class="p">;</span> <span class="n">The</span> <span class="n">SMT</span> <span class="n">solver</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">prove</span> <span class="n">the</span> <span class="n">query</span><span class="p">,</span> <span class="k">try</span> <span class="n">to</span>
<span class="n">spell</span> <span class="n">your</span> <span class="n">proof</span> <span class="ow">in</span> <span class="n">more</span> <span class="n">detail</span> <span class="ow">or</span> <span class="n">increase</span> <span class="n">fuel</span><span class="o">/</span><span class="n">ifuel</span> <span class="p">(</span><span class="n">see</span> <span class="n">also</span> <span class="n">prims</span><span class="o">.</span><span class="n">fst</span><span class="p">(</span><span class="mi">626</span><span class="p">,</span>
<span class="mi">18</span><span class="o">-</span><span class="mi">626</span><span class="p">,</span><span class="mi">24</span><span class="p">))</span>
<span class="n">Verified</span> <span class="n">module</span><span class="p">:</span> <span class="n">Sample</span>
<span class="mi">1</span> <span class="n">error</span> <span class="n">was</span> <span class="n">reported</span> <span class="p">(</span><span class="n">see</span> <span class="n">above</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>ソース位置</strong></p>
<p>エラーメッセージは <code class="docutils literal notranslate"><span class="pre">Sample.fst(11,26-11,31)</span></code> を指しています。これは、ファイル名・開始位置（行・列）・終了位置（行・列）からなるソース範囲です。この例では <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> の項がハイライトされます。</p>
<p><strong>重要度とエラーコード</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">(Error</span> <span class="pre">19)</span></code> は重要度（ここでは <code class="docutils literal notranslate"><span class="pre">Error</span></code>。例えば <code class="docutils literal notranslate"><span class="pre">Warning</span></code> ではありません）と、エラーコード（<code class="docutils literal notranslate"><span class="pre">19</span></code>）を示します。</p>
<p><strong>エラーメッセージ</strong></p>
<p>メッセージの前半は予想どおりの内容です。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Subtyping</span> <span class="n">check</span> <span class="n">failed</span><span class="p">;</span> <span class="n">expected</span> <span class="nb">type</span> <span class="n">Prims</span><span class="o">.</span><span class="n">nat</span><span class="p">;</span> <span class="n">got</span> <span class="nb">type</span> <span class="n">Prims</span><span class="o">.</span><span class="n">int</span>
</pre></div>
</div>
<p>以降のメッセージには詳細が続きますが、F* と SMT ソルバの連携について説明するまでは一旦省きます。ただし、次の一節はここで指摘しておく価値があります。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">see</span> <span class="n">also</span> <span class="n">prims</span><span class="o">.</span><span class="n">fst</span><span class="p">(</span><span class="mi">626</span><span class="p">,</span><span class="mi">18</span><span class="o">-</span><span class="mi">626</span><span class="p">,</span><span class="mi">24</span><span class="p">))</span>
</pre></div>
</div>
<p>エラーメッセージには、括弧内の “see also” として補助的なソース位置が示されることがあります。これは F* がプログラムを拒否した理由の手掛かりになります。今回の例では <code class="docutils literal notranslate"><span class="pre">prims.fst</span></code> 内の <code class="docutils literal notranslate"><span class="pre">nat</span></code> の定義にある制約 <code class="docutils literal notranslate"><span class="pre">x&gt;=0</span></code> を指しており、これが F* によって証明できなかった特定の制約であることを示しています。</p>
<p>では、もう一度やってみましょう。ここに <code class="docutils literal notranslate"><span class="pre">incr</span></code> の別の型があります。引数が自然数なら結果も自然数であると主張しています。今回は F* も受け入れます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr3 (x:nat) : nat = x + 1
</pre></div>
</div>
<p>ときには、定義とは独立に型シグネチャを与えると便利です。以下では <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">incr4</span></code> がシグネチャだけを与え、続く <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">incr4</span></code> が定義を与えます。F* は定義がシグネチャと整合しているかを検査します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> incr4 (x:int) : int
<span class="k">let</span> incr4 x = x + 1
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">incr</span></code> に別の型をいくつか与えてみてください。（<a class="reference external" href="../code/exercises/Part1.GettingOffTheGround.fst">演習を読み込む</a>）</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>いくつかの解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> incr5 (x:int) : y:int{y = x + 1} = x + 1
<span class="k">let</span> incr6 (x:int) : y:int{x = y - 1} = x + 1
<span class="k">let</span> incr7 (x:int) : y:int{<span class="k">if</span> x%2 = 0 <span class="k">then</span> y%2 = 1 <span class="k">else</span> y%2 = 0} = x + 1
</pre></div>
</div>
</div>
</section>
<section id="computing-the-maximum-of-two-integers">
<h3>2 つの整数の最大値を計算する<a class="headerlink" href="#computing-the-maximum-of-two-integers" title="Link to this heading"></a></h3>
<p>次のシグネチャの実装を与えなさい。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="nb">max</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>このシグネチャを満たす実装は多数あり、例えば次のような自明なものも含まれます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="nb">max</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の最大値を正しく返さない定義を排除できるほど精密な型と組み合わせて、<code class="docutils literal notranslate"><span class="pre">max</span></code> の実装を与えなさい。</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>いくつかの解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> max (x:int) (y:int) : int
<span class="k">let</span> max x y = <span class="k">if</span> x &gt;= y <span class="k">then</span> x <span class="k">else</span> y

<span class="k">val</span> max1 (x:int) (y:int)
  : z:int{ z &gt;= x &amp;&amp; z &gt;= y &amp;&amp; (z = x || z = y)}
<span class="k">let</span> max1 x y = <span class="k">if</span> x &gt;= y <span class="k">then</span> x <span class="k">else</span> y

<span class="k">let</span> max2 (x:int) (y:int)
  : z:int{ z = max x y }
  = <span class="k">if</span> x &gt; y
    <span class="k">then</span> x
    <span class="k">else</span> y
</pre></div>
</div>
</div>
</section>
<section id="more-types-for-factorial">
<h3>factorial に与えられる別の型<a class="headerlink" href="#more-types-for-factorial" title="Link to this heading"></a></h3>
<p>先ほどの <code class="docutils literal notranslate"><span class="pre">factorial</span></code> の定義を思い出してください。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> FStar.Mul
<span class="k">let</span> <span class="k">rec</span> factorial (n:nat)
  : nat
  = <span class="k">if</span> n = 0
    <span class="k">then</span> 1
    <span class="k">else</span> n * factorial (n - 1)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">factorial</span></code> に対して、さらに別の型をいくつか書けますか？</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>いくつかの解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial1 (n:nat)
  : int
  = <span class="k">if</span> n = 0
    <span class="k">then</span> 1
    <span class="k">else</span> n * factorial1 (n - 1)

<span class="k">let</span> <span class="k">rec</span> factorial2 (n:nat)
  : y:int{y&gt;=1}
  = <span class="k">if</span> n = 0
    <span class="k">then</span> 1
    <span class="k">else</span> n * factorial2 (n - 1)
</pre></div>
</div>
</div>
</section>
<section id="fibonacci">
<h3>フィボナッチ<a class="headerlink" href="#fibonacci" title="Link to this heading"></a></h3>
<p>二重再帰の関数を示します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fibonacci (n:nat)
  : nat
  = <span class="k">if</span> n &lt;= 1
    <span class="k">then</span> 1
    <span class="k">else</span> fibonacci (n - 1) + fibonacci (n - 2)
</pre></div>
</div>
<p>この関数には他にどのような型を与えられるでしょうか？</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>いくつかの解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> fibonacci_1 : x:int -&gt; y:int{y &gt;= 1 /\ y &gt;= x /\ (<span class="k">if</span> x&gt;=3 <span class="k">then</span> y &gt;= 2 <span class="k">else</span> <span class="k">true</span>)}
<span class="k">let</span> <span class="k">rec</span> fibonacci_1 n =
  <span class="k">if</span> n &lt;= 1 <span class="k">then</span> 1 <span class="k">else</span> fibonacci_1 (n - 1) + fibonacci_1 (n - 2)

<span class="c">(* Try these other types too *)</span>
<span class="c">(* val fibonacci_1 : int -&gt; int *)</span>
<span class="c">(* val fibonacci_1 : int -&gt; nat *)</span>
<span class="c">(* val fibonacci_1 : int -&gt; y:int{y&gt;=1} *)</span>
<span class="c">(* val fibonacci_1 : x:int -&gt; y:int{y&gt;=1 /\ y &gt;= x} *)</span>
<span class="c">(* val fibonacci_1 : int -&gt; Tot (x:nat{x&gt;0}) *)</span>
</pre></div>
</div>
</div>
</section>
</section>
</section>


           </div>
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="part1.html" class="btn btn-neutral float-left" title="全域関数によるプログラミングと証明" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="part1_polymorphism.html" class="btn btn-neutral float-right" title="多相と型推論" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>