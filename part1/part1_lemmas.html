

<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>補題と帰納法による証明 &mdash; Proof-Oriented Programming in F*  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=24463673" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c033477b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=4755f45a"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="ケーススタディ：クイックソート" href="part1_quicksort.html" />
    <link rel="prev" title="停止性の証明" href="part1_termination.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Proof-Oriented Programming in F*
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../structure.html">本書の構成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">イントロダクション</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part1.html">全域関数によるプログラミングと証明</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="part1_getting_off_the_ground.html">まずは始めてみよう</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_polymorphism.html">多相と型推論</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_equality.html">等値性（Equality）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_prop_assertions.html">SMT ソルバとの連携</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_inductives.html">帰納的データ型とパターンマッチ</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_termination.html">停止性の証明</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">補題と帰納法による証明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introducing-lemmas">補題の導入</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#some-syntactic-shorthands-for-lemmas">補題のためのいくつかの構文上の省略表記</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-proof-by-induction-explained-in-detail">帰納法による証明の詳細</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises-lemmas-about-integer-functions">練習問題：整数関数に関する補題</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exercise-1">演習 1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-2">演習 2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercise-a-lemma-about-append">演習：append に関する補題</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intrinsic-vs-extrinsic-proofs">内的（intrinsic）証明と外的（extrinsic）証明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exercises-reverse-is-injective">練習問題：reverse は単射である</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-optimizing-reverse">演習：reverse の最適化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-optimizing-fibonacci">演習：Fibonacci の最適化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#higher-order-functions">高階関数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exercise-finding-a-list-element">演習：リスト要素の検索</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise-fold-left">演習：fold_left</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="part1_quicksort.html">ケーススタディ：クイックソート</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_execution.html">プログラムの実行</a></li>
<li class="toctree-l2"><a class="reference internal" href="part1_wrap.html">まとめ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part2/part2.html">帰納的型によるデータ・証明・計算の表現</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part3/part3.html">インターフェースと型クラスによるモジュール性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part4/part4.html">計算効果</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part5/part5.html">Meta-F* によるタクティクスとメタプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/pulse.html">Pulse: 並行分離論理における証明指向プログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../under_the_hood/under_the_hood.html">内部の仕組み</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part1.html">全域関数によるプログラミングと証明</a></li>
      <li class="breadcrumb-item active">補題と帰納法による証明</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <section id="lemmas-and-proofs-by-induction">
<span id="part1-lemmas"></span><h1>補題と帰納法による証明<a class="headerlink" href="#lemmas-and-proofs-by-induction" title="Link to this heading"></a></h1>
<p>たとえば <code class="docutils literal notranslate"><span class="pre">factorial</span></code> 関数を書き、型を <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">-&gt;</span> <span class="pre">nat</span></code> としました。後になって <code class="docutils literal notranslate"><span class="pre">factorial</span></code> について別の性質（例：<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">2</span></code> なら <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">x</span></code>）を気にするようになったとします。一つのやり方は、<code class="docutils literal notranslate"><span class="pre">factorial</span></code> の型を改訂して F* にその型で再証明させることですが、いつも現実的とは限りません。たとえばさらに「<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">3</span></code> なら <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span></code>」も示したくなるかもしれません。このような性質をすべて（将来必要かどうかも分からないものまで）``factorial`` の型に詰め込むのは非現実的です。</p>
<p>これらの性質を F* に検査させるアサーションを書くこともできます。例えば、</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">_</span> = <span class="k">assert</span> (<span class="k">forall</span> (x:nat). x &gt; 2 ==&gt; factorial x &gt; 2)
</pre></div>
</div>
<p>しかし、F* は「この事実を証明できない」と文句を言うかもしれません。これは事実が偽だからではありません—F* におけるアサーションの妥当性検査は決定不能であることを思い出してください。したがって、真ではあるが（少なくとも何らかの助けなしには）F* が証明できない事実がありえます。</p>
<p>この場合、<code class="docutils literal notranslate"><span class="pre">factorial</span></code> に関する性質の証明には帰納法が必要です。F* と Z3 は帰納法の証明を自動では行えません—ここでは <em>補題（lemma）</em> を書いて F* を助ける必要があります。</p>
<section id="introducing-lemmas">
<h2>補題の導入<a class="headerlink" href="#introducing-lemmas" title="Link to this heading"></a></h2>
<p>補題は F* における関数で、常に <code class="docutils literal notranslate"><span class="pre">():unit</span></code> を返します。ただし補題の“型”には、どの事実が証明されているかという有用な情報が含まれます。</p>
<p>最初の補題を示します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_is_positive (x:nat)
  : u:unit{factorial x &gt; 0}
  = <span class="k">if</span> x = 0 <span class="k">then</span> ()
    <span class="k">else</span> factorial_is_positive (x - 1)
</pre></div>
</div>
<p>この定義には多くの情報が凝縮されています。詳しく説明しましょう。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">factorial_is_positive</span></code> は引数 <code class="docutils literal notranslate"><span class="pre">x:nat</span></code> を取る再帰関数です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">factorial_is_positive</span></code> の戻り値の型は unit の精錬で、<code class="docutils literal notranslate"><span class="pre">u:unit{factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0}</span></code> です。これは関数が常に <code class="docutils literal notranslate"><span class="pre">()</span></code> を返すだけでなく、（全域関数なので必ず返りますが）``factorial_is_positive x`` が返った時点で <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> と結論してよいことを意味します。</p></li>
<li><p>続く 3 行で、<code class="docutils literal notranslate"><span class="pre">x</span></code> に関する帰納法を用いて補題を証明しています。ここでの基本的な考え方は、全域関数としてプログラムを書くことで、他の純粋な式についての証明を書ける、ということです。この種の証明については、この節の残りで詳しく述べます。</p></li>
</ul>
<section id="some-syntactic-shorthands-for-lemmas">
<span id="part1-lemma-syntax"></span><h3>補題のためのいくつかの構文上の省略表記<a class="headerlink" href="#some-syntactic-shorthands-for-lemmas" title="Link to this heading"></a></h3>
<p>補題は F* で非常によく使うため、専用の構文が用意されています。<code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> の証明を別の書き方で示します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_is_pos (x:int)
  : <span class="k">Lemma</span> (<span class="k">requires</span> x &gt;= 0)
          (<span class="k">ensures</span> factorial x &gt; 0)
  = <span class="k">if</span> x = 0 <span class="k">then</span> ()
    <span class="k">else</span> factorial_is_pos (x - 1)
</pre></div>
</div>
<p>型 <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">-&gt;</span> <span class="pre">Lemma</span> <span class="pre">(requires</span> <span class="pre">pre)</span> <span class="pre">(ensures</span> <span class="pre">post)</span></code> は、次の性質をもつ関数の型です。</p>
<ul class="simple">
<li><p>引数 <code class="docutils literal notranslate"><span class="pre">v:t</span></code> で呼び出せること。</p></li>
<li><p>その引数は前提条件 <code class="docutils literal notranslate"><span class="pre">pre[v/x]</span></code> を満たさなければならないこと。</p></li>
<li><p>関数は常に <code class="docutils literal notranslate"><span class="pre">unit</span></code> を返すこと。</p></li>
<li><p>そして事後条件 <code class="docutils literal notranslate"><span class="pre">post[v/x]</span></code> が成り立つことを保証すること。</p></li>
</ul>
<p>この型は <code class="docutils literal notranslate"><span class="pre">x:t{pre}</span> <span class="pre">-&gt;</span> <span class="pre">u:unit{post}</span></code> と同値です。</p>
<p>前提条件 <code class="docutils literal notranslate"><span class="pre">pre</span></code> が自明なときは省略できます。次のように書けます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">Lemma</span> (<span class="k">ensures</span> post)
</pre></div>
</div>
<p>あるいは次のようにも書けます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">Lemma</span> post
</pre></div>
</div>
</section>
<section id="a-proof-by-induction-explained-in-detail">
<h3>帰納法による証明の詳細<a class="headerlink" href="#a-proof-by-induction-explained-in-detail" title="Link to this heading"></a></h3>
<p>この補題をもう一度詳しく見てみましょう—なぜ F* は <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> を納得できるのでしょうか。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_is_pos (x:int)
  : <span class="k">Lemma</span> (<span class="k">requires</span> x &gt;= 0)
          (<span class="k">ensures</span> factorial x &gt; 0)
  = <span class="k">if</span> x = 0 <span class="k">then</span> ()
    <span class="k">else</span> factorial_is_pos (x - 1)
</pre></div>
</div>
<ul>
<li><p>これは <code class="docutils literal notranslate"><span class="pre">x</span></code> に関する帰納法の証明です。F* における帰納法の証明は、全域の再帰関数で表現されます。全域であるという事実は非常に重要で、帰納法の議論が整礎的である（帰納法の仮定が厳密に小さい引数にのみ適用される）ことを保証します。</p></li>
<li><p>基底の場合は <code class="docutils literal notranslate"><span class="pre">x=0</span></code> です。この場合は <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">0</span></code> を <code class="docutils literal notranslate"><span class="pre">1</span></code> に計算し <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> を確かめるだけなので、F* + Z3 は容易に証明できます。</p></li>
<li><p>残るのは <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> の場合です。</p></li>
<li><p>帰納の場合、再帰的に束縛された <code class="docutils literal notranslate"><span class="pre">factorial_is_pos</span></code> の“型”が帰納法の仮定を表します。ここでの型は次のとおりです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span>y:int {y &lt; x} -&gt; <span class="k">Lemma</span> (<span class="k">requires</span> y &gt;= 0) (<span class="k">ensures</span> factorial y &gt; 0)
</pre></div>
</div>
<p>言い換えれば、再帰関数の型が、現在の引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> より小さく非負のすべての <code class="docutils literal notranslate"><span class="pre">y</span></code> について <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> と仮定してよいことを教えてくれます。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">x-1</span></code> に対して再帰呼び出しをすることで、F* は <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> を結論できます。</p></li>
<li><p>最後に <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> を示すため、ソルバは <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">factorial</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">1)</span></code> を用います。再帰呼び出しから <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">(x</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> が分かっており、いま <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> の場合なので、正の数どうしの積が正であることから結論できます。</p></li>
</ul>
</section>
</section>
<section id="exercises-lemmas-about-integer-functions">
<h2>練習問題：整数関数に関する補題<a class="headerlink" href="#exercises-lemmas-about-integer-functions" title="Link to this heading"></a></h2>
<p>演習ファイルは <a class="reference external" href="../code/exercises/Part1.Lemmas.fst">こちら</a>。</p>
<section id="exercise-1">
<h3>演習 1<a class="headerlink" href="#exercise-1" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">factorial</span></code> について、次の補題を証明してみましょう。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> factorial_is_greater_than_arg (x:int)
  : <span class="k">Lemma</span> (<span class="k">requires</span> x &gt; 2)
          (<span class="k">ensures</span> factorial x &gt; x)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_is_greater_than_arg (x:int)
  : <span class="k">Lemma</span> (<span class="k">requires</span> x &gt; 2)
          (<span class="k">ensures</span> factorial x &gt; x)
  = <span class="k">if</span> x = 3 <span class="k">then</span> ()
    <span class="k">else</span> factorial_is_greater_than_arg (x - 1)
</pre></div>
</div>
</div>
</section>
<section id="exercise-2">
<h3>演習 2<a class="headerlink" href="#exercise-2" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">fibonacci</span></code> について、次の補題を証明してみましょう。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fibonacci (n:nat)
  : nat
  = <span class="k">if</span> n &lt;= 1
    <span class="k">then</span> 1
    <span class="k">else</span> fibonacci (n - 1) + fibonacci (n - 2)

<span class="k">val</span> fibonacci_greater_than_arg (n:nat{n &gt;= 2})
  : <span class="k">Lemma</span> (fibonacci n &gt;= n)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>解答**（2 つの証明と詳細な解説を含む）</p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fibonacci_greater_than_arg (n:nat{n &gt;= 2})
  : <span class="k">Lemma</span> (fibonacci n &gt;= n)
  = <span class="k">if</span> n &lt;= 3 <span class="k">then</span> ()
    <span class="k">else</span> (
      fibonacci_greater_than_arg (n - 1);
      fibonacci_greater_than_arg (n - 2)
    )
</pre></div>
</div>
<p>その証明を少し詳しく見てみましょう。先ほど詳述した帰納法の証明とよく似ていますが、ここでは帰納法の仮定を 2 回使う点が異なります。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">rec</span></code> から分かるように、<code class="docutils literal notranslate"><span class="pre">n:nat{n</span> <span class="pre">&gt;=</span> <span class="pre">2}</span></code> に関する帰納法の証明です。</p></li>
<li><p>基底の場合は <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2</span></code> と <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">3</span></code> です。いずれも <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">n</span></code> を計算して <code class="docutils literal notranslate"><span class="pre">n</span></code> より大きいことを確かめるだけです。</p></li>
<li><p>それ以外、すなわち帰納の場合は <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">4</span></code> で、帰納法の仮定は再帰関数の型として表れます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">:</span><span class="n">nat</span><span class="p">{</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">/</span>\ <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Lemma</span> <span class="p">(</span><span class="n">fibonacci</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>帰納法の仮定を 2 回用いると次が得られます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>
</pre></div>
</div>
</li>
<li><p>あとは次を示せば十分です。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="o">//</span><span class="n">by</span> <span class="n">definition</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">//</span><span class="kn">from</span><span class="w"> </span><span class="nn">the</span> <span class="n">facts</span> <span class="n">above</span>
<span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="o">//</span><span class="n">rearrange</span>
<span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&gt;=</span>  <span class="o">//</span><span class="n">when</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">4</span>
<span class="n">n</span>
</pre></div>
</div>
</li>
</ul>
<p>見てのとおり、帰納法の枠組みを整えれば、あとは SMT ソルバが多くの作業を肩代わりしてくれます。</p>
<p>ときには、SMT ソルバは自分では思いつかない証明を見つけることすらあります。<code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">n</span></code> の別証を考えてみましょう。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fib_greater_than_arg (n:nat{n &gt;= 2})
  : <span class="k">Lemma</span> (fibonacci n &gt;= n)
  = <span class="k">if</span> n = 2 <span class="k">then</span> ()
    <span class="k">else</span> (
      fib_greater_than_arg (n - 1)
    )
</pre></div>
</div>
<p>この証明は、帰納法の仮定を 1 回使うだけで成り立ちます。なぜでしょうか？ 詳しく見てみましょう。</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">n:nat{n</span> <span class="pre">&gt;=</span> <span class="pre">2}</span></code> に関する帰納法の証明です。</p></li>
<li><p>基底は <code class="docutils literal notranslate"><span class="pre">n=2</span></code>。<code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">2</span></code> を計算して 2 以上であることを確かめれば十分です。</p></li>
<li><p>帰納の場合は次のとおりです。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span>
</pre></div>
</div>
</li>
<li><p>帰納法の仮定は次のとおりです。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">:</span><span class="n">nat</span><span class="p">{</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">/</span>\ <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Lemma</span> <span class="p">(</span><span class="n">fibonacci</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> に仮定を適用して次を得ます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p>さらに次が成り立ちます。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="o">//</span><span class="n">definition</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">//</span><span class="kn">from</span><span class="w"> </span><span class="mi">5</span>
<span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>したがって、今の目標は次のとおりです。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code> を示せれば十分です。</p></li>
<li><p>From (2) and the definition of <code class="docutils literal notranslate"><span class="pre">fibonacci</span></code> we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">//</span><span class="n">definition</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">//</span><span class="kn">from</span><span class="w"> </span><span class="mi">5</span>
<span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="o">//</span> <span class="kn">from</span><span class="w"> </span><span class="mi">3</span>
<span class="mi">2</span>
</pre></div>
</div>
</li>
<li><p>さて、背理法で <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">=</span> <span class="pre">0</span></code> と仮定します。</p>
<p>10.1. すると 9 より、<code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-3)</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>。</p>
<p>10.2  もし <code class="docutils literal notranslate"><span class="pre">n=3</span></code> なら <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">1</span></code> で矛盾。</p>
<p>10.3  <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">3</span></code> の場合、</p>
<blockquote>
<div><p>10.3.1. 定義より <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-2)</span> <span class="pre">=</span> <span class="pre">fibonacci</span> <span class="pre">(n-3)</span> <span class="pre">+</span> <span class="pre">fibonacci</span> <span class="pre">(n-4)</span></code>。</p>
<p>10.3.2. <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-4)</span> <span class="pre">:</span> <span class="pre">nat</span></code> なので、<code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-3)</span> <span class="pre">+</span> <span class="pre">fibonacci</span> <span class="pre">(n-4)</span> <span class="pre">&gt;=</span> <span class="pre">fibonacci</span> <span class="pre">(n-3)</span></code>。</p>
<p>10.3.3. 10.3.1 と 10.3.2 より <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-2)</span> <span class="pre">&gt;=</span> <span class="pre">fibonacci</span> <span class="pre">(n-3)</span></code>。</p>
<p>10.3.4. 10.1 より <code class="docutils literal notranslate"><span class="pre">fibonacci</span> <span class="pre">(n-2)</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>。</p>
<p>10.3.5. しかし 10.3.4 は 10 に矛盾。よって証明完了。</p>
</div></blockquote>
</li>
</ol>
<p>おそらく自力では思いつかなかった証明でしょう。実際、私たちも SMT ソルバが帰納法の仮定 1 回でこの補題をどう証明できたのか理解するのに少し悩みました。いずれにせよ、SMT ソルバは非常に強力だということです！</p>
</div>
</section>
</section>
<section id="exercise-a-lemma-about-append">
<h2>演習：append に関する補題<a class="headerlink" href="#exercise-a-lemma-about-append" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="part1_inductives.html#part1-inductives-append"><span class="std std-ref">以前</span></a>、次の型をもつ <code class="docutils literal notranslate"><span class="pre">append</span></code> の定義を見ました。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> append (#a:Type) (l1 l2:list a)
  : l:list a{length l = length l1 + length l2}
</pre></div>
</div>
<p>ここで、より弱い型をもつ <code class="docutils literal notranslate"><span class="pre">append</span></code> の変種として <code class="docutils literal notranslate"><span class="pre">app</span></code> を次のように定義するとします。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> app #a (l1 l2:list a)
  : list a
  = <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; l2
    | hd :: tl -&gt; hd :: app tl l2
</pre></div>
</div>
<p>次の補題を証明できますか？</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> app_length (#a:Type) (l1 l2:list a)
  : <span class="k">Lemma</span> (length (app l1 l2) = length l1 + length l2)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> app_length #a l1 l2
  = <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; ()
    | <span class="k">_</span> :: tl -&gt; app_length tl l2
</pre></div>
</div>
</div>
</section>
<section id="intrinsic-vs-extrinsic-proofs">
<span id="part1-intrinsic-extrinsic"></span><h2>内的（intrinsic）証明と外的（extrinsic）証明<a class="headerlink" href="#intrinsic-vs-extrinsic-proofs" title="Link to this heading"></a></h2>
<p>前の演習が示すように、性質は関数の型を豊かにして示すことも、別の補題を書いて示すこともできます—それぞれを内的・外的スタイルと呼びます。どちらを選ぶかは好みや便宜の問題です。一般に有用な性質（例：<code class="docutils literal notranslate"><span class="pre">length</span></code> が <code class="docutils literal notranslate"><span class="pre">nat</span></code> を返す）は内的仕様に向き、より特化した性質は補題として述べて証明するのがよいでしょう。ただし次の例のように、関数の型の中で直接その性質を証明することが不可能な場合もあり、そのときは補題に頼る必要があります。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> reverse #a (l:list a)
  : list a
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; []
    | hd :: tl -&gt; append (reverse tl) [hd]
</pre></div>
</div>
<p>リストを 2 回反転すると恒等になることを証明してみましょう。これは精錬型を使えば <code class="docutils literal notranslate"><span class="pre">reverse</span></code> の型として <em>仕様化</em> できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> reverse (#a:Type) : f:(list a -&gt; list a){<span class="k">forall</span> l. l == f (f l)}
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>注意点：上の <code class="docutils literal notranslate"><span class="pre">reverse</span></code> の精錬では <a class="reference internal" href="part1_prop_assertions.html#part1-ch2-propositional-equality"><span class="std std-ref">命題的等値</span></a> を使っています。これは任意型のリストに対する等値は決定可能とは限らないためです（<code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">(int</span> <span class="pre">-&gt;</span> <span class="pre">int)</span></code> を考えてみてください）。以下の証明はすべて命題的等値に依拠します。</p>
</div>
<p>しかし F* は、これを <code class="docutils literal notranslate"><span class="pre">reverse</span></code> の正当な型としては受け入れません。この性質の証明には 2 回の帰納法が必要で、F* はそのいずれも自動では行えないためです。</p>
<p>代わりに、2 つの補題を使って望む性質を証明できます。以下がその内容です。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="c">(* snoc is &quot;cons&quot; backwards --- it adds an element to the end of a list *)</span>
<span class="k">let</span> snoc l h = append l [h]

<span class="k">let</span> <span class="k">rec</span> snoc_cons #a (l:list a) (h:a)
  : <span class="k">Lemma</span> (reverse (snoc l h) == h :: reverse l)
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; ()
    | hd :: tl -&gt; snoc_cons tl h

<span class="k">let</span> <span class="k">rec</span> rev_involutive #a (l:list a)
  : <span class="k">Lemma</span> (reverse (reverse l) == l)
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; ()
    | hd :: tl -&gt;
      <span class="c">// (1) [reverse (reverse tl) == tl]</span>
      rev_involutive tl;
      <span class="c">// (2) [reverse (append (reverse tl) [hd]) == h :: reverse (reverse tl)]</span>
      snoc_cons (reverse tl) hd
      <span class="c">// These two facts are enough for Z3 to prove the lemma:</span>
      <span class="c">//   reverse (reverse (hd :: tl))</span>
      <span class="c">//   =def= reverse (append (reverse tl) [hd])</span>
      <span class="c">//   =(2)= hd :: reverse (reverse tl)</span>
      <span class="c">//   =(1)= hd :: tl</span>
      <span class="c">//   =def= l</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rev_involutive</span></code> の <code class="docutils literal notranslate"><span class="pre">hd</span> <span class="pre">::</span> <span class="pre">tl</span></code> の場合では、帰納法の仮定だけでなく、そこで証明した補助補題 <code class="docutils literal notranslate"><span class="pre">snoc_cons</span></code> も明示的に適用しています。</p>
<section id="exercises-reverse-is-injective">
<h3>練習問題：reverse は単射である<a class="headerlink" href="#exercises-reverse-is-injective" title="Link to this heading"></a></h3>
<p>演習ファイルは <a class="reference external" href="../code/exercises/Part1.Lemmas.fst">こちら</a>。</p>
<p>reverse が単射であること、すなわち次の補題を証明しなさい。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> rev_injective (#a:Type) (l1 l2:list a)
  : <span class="k">Lemma</span> (<span class="k">requires</span> reverse l1 == reverse l2)
          (<span class="k">ensures</span>  l1 == l2)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> snoc_injective (#a:Type) (l1:list a) (h1:a) (l2:list a) (h2:a)
  : <span class="k">Lemma</span> (<span class="k">requires</span> snoc l1 h1 == snoc l2 h2)
          (<span class="k">ensures</span> l1 == l2 /\ h1 == h2)
  = <span class="k">match</span> l1, l2 <span class="k">with</span>
    | <span class="k">_</span> :: tl1, <span class="k">_</span> :: tl2 -&gt; snoc_injective tl1 h1 tl2 h2
    | <span class="k">_</span> -&gt; ()


<span class="k">let</span> <span class="k">rec</span> rev_injective l1 l2 =
  <span class="k">match</span> l1,l2 <span class="k">with</span>
  | h1::t1, h2::t2 -&gt;
      <span class="c">// assert(reverse (h1::t1) = reverse (h2::t2));</span>
      <span class="c">// assert(snoc (reverse t1) h1  = snoc (reverse t2) h2);</span>
      snoc_injective (reverse t1) h1 (reverse t2) h2;
      <span class="c">// assert(reverse t1 = reverse t2 /\ h1 = h2);</span>
      rev_injective t1 t2
      <span class="c">// assert(t1 = t2 /\ h1::t1 = h2::t2)</span>
  | <span class="k">_</span>, <span class="k">_</span> -&gt; ()
</pre></div>
</div>
<p>なかなか骨の折れる証明でしたね。より簡単な証明を示します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> rev_injective_alt (#a:Type) (l1 l2:list a)
  : <span class="k">Lemma</span> (<span class="k">requires</span> reverse l1 == reverse l2)
          (<span class="k">ensures</span>  l1 == l2)
  = rev_involutive l1; rev_involutive l2
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rev_injective_alt</span></code> の証明は、可逆な関数は単射であるという考えに基づきます。すでに <code class="docutils literal notranslate"><span class="pre">reverse</span></code> が自己逆（involutive）であることを示しました。したがって、この補題を <code class="docutils literal notranslate"><span class="pre">l1</span></code> と <code class="docutils literal notranslate"><span class="pre">l2</span></code> にそれぞれ適用します。これにより SMT ソルバには <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(reverse</span> <span class="pre">l1)</span> <span class="pre">=</span> <span class="pre">l1</span></code> と <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(reverse</span> <span class="pre">l2)</span> <span class="pre">=</span> <span class="pre">l2</span></code> の情報が与えられ、証明が完了します。いつものとおり、証明の構成では補題が頼りになります！</p>
</div>
</section>
<section id="exercise-optimizing-reverse">
<h3>演習：reverse の最適化<a class="headerlink" href="#exercise-optimizing-reverse" title="Link to this heading"></a></h3>
<p>先に、<code class="docutils literal notranslate"><span class="pre">reverse</span></code> の <a class="reference internal" href="part1_termination.html#part1-termination-reverse"><span class="std std-ref">末尾再帰版</span></a> の実装を見ました。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> rev_aux #a (l1 l2:list a)
  : <span class="k">Tot</span> (list a) (<span class="k">decreases</span> l2)
  = <span class="k">match</span> l2 <span class="k">with</span>
    | []     -&gt; l1
    | hd :: tl -&gt; rev_aux (hd :: l1) tl

<span class="k">let</span> rev #a (l:list a) : list a = rev_aux [] l
</pre></div>
</div>
<p>次の補題を証明し、先の非末尾再帰の実装と同値であることを示しなさい。すなわち、</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> rev_is_ok (#a:<span class="k">_</span>) (l:list a) : <span class="k">Lemma</span> (rev [] l == reverse l)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> rev_is_ok_aux #a (l1 l2:list a)
  : <span class="k">Lemma</span> (<span class="k">ensures</span> (rev_aux l1 l2 == append (reverse l2) l1))
          (<span class="k">decreases</span> l2)
  = <span class="k">match</span> l2 <span class="k">with</span>
    | [] -&gt; ()
    | hd :: tl  -&gt; rev_is_ok_aux (hd :: l1) tl;
                 append_assoc (reverse tl) [hd] l1

<span class="k">let</span> rev_is_ok #a (l:list a)
  : <span class="k">Lemma</span> (rev l == reverse l)
  = rev_is_ok_aux [] l;
    append_right_unit (reverse l)
</pre></div>
</div>
</div>
</section>
<section id="exercise-optimizing-fibonacci">
<h3>演習：Fibonacci の最適化<a class="headerlink" href="#exercise-optimizing-fibonacci" title="Link to this heading"></a></h3>
<p>先に、<code class="docutils literal notranslate"><span class="pre">fibonacci</span></code> の <a class="reference internal" href="part1_termination.html#part1-termination-fibonacci"><span class="std std-ref">末尾再帰版</span></a> の実装を見ました—以下に再掲します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fib (a b n:nat)
  : <span class="k">Tot</span> nat (<span class="k">decreases</span> n)
  = <span class="k">match</span> n <span class="k">with</span>
    | 0 -&gt; a
    | <span class="k">_</span> -&gt; fib b (a+b) (n-1)

<span class="k">let</span> fib_tail (n:nat) : nat = fib 1 1 n
</pre></div>
</div>
<p>次の補題を証明し、非末尾再帰の実装と同値であることを示しなさい。すなわち、</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> fib_tail_is_ok (n:nat)
  : <span class="k">Lemma</span> (fib_tail n == fibonacci n)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fib_is_ok_aux (n: nat) (k: nat)
  : <span class="k">Lemma</span> (fib (fibonacci k)
               (fibonacci (k + 1)) n == fibonacci (k + n))
  = <span class="k">if</span> n = 0 <span class="k">then</span> () <span class="k">else</span> fib_is_ok_aux (n - 1) (k + 1)

<span class="k">let</span> fib_tail_is_ok (n:nat)
  : <span class="k">Lemma</span> (fib_tail n == fibonacci n)
  = fib_is_ok_aux n 0
</pre></div>
</div>
</div>
</section>
</section>
<section id="higher-order-functions">
<span id="part1-higher-order-functions"></span><h2>高階関数<a class="headerlink" href="#higher-order-functions" title="Link to this heading"></a></h2>
<p>関数は第一級の値であり、他の関数に渡したり結果として返したりできます。<a class="reference internal" href="part1_polymorphism.html#part1-polymorphism-and-inference"><span class="std std-ref">多相</span></a> の節でもいくつか例を見ました。ここではリストに対する <code class="docutils literal notranslate"><span class="pre">map</span></code> から、さらにいくつか見ていきます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> map #a #b (f: a -&gt; b) (l:list a)
  : list b
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; []
    | hd::tl -&gt; f hd :: map f tl
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> とリスト <code class="docutils literal notranslate"><span class="pre">l</span></code> を取り、<code class="docutils literal notranslate"><span class="pre">l</span></code> の各要素に <code class="docutils literal notranslate"><span class="pre">f</span></code> を適用して新しいリストを作ります。より正確には、<code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">[v1;</span> <span class="pre">...;</span> <span class="pre">vn]</span></code> は <code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">v1;</span> <span class="pre">...;</span> <span class="pre">f</span> <span class="pre">vn]</span></code> を生成します。例：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span>map (<span class="k">fun</span> x -&gt; x + 1) [0; 1; 2] = [1; 2; 3]
</pre></div>
</div>
<section id="exercise-finding-a-list-element">
<h3>演習：リスト要素の検索<a class="headerlink" href="#exercise-finding-a-list-element" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">find</span></code> という関数を示します。これはブール関数 <code class="docutils literal notranslate"><span class="pre">f</span></code> とリスト <code class="docutils literal notranslate"><span class="pre">l</span></code> を受け取り、<code class="docutils literal notranslate"><span class="pre">f</span></code> が成り立つ <code class="docutils literal notranslate"><span class="pre">l</span></code> の最初の要素を返します。見つからない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> find f l =
  <span class="k">match</span> l <span class="k">with</span>
  | [] -&gt; None
  | hd :: tl -&gt; <span class="k">if</span> f hd <span class="k">then</span> Some hd <span class="k">else</span> find f tl
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">find</span></code> が <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">x</span></code> を返すなら <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">true</span></code> であることを証明しなさい。これは内的・外的のどちらで示すのがよいでしょうか？ 両方のやり方で行ってみましょう。</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> find (#a:Type) (f: a -&gt; bool) (l:list a)
  : o:option a{ Some? o ==&gt; f (Some?.v o)}
</pre></div>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> find_alt f l =
  <span class="k">match</span> l <span class="k">with</span>
  | [] -&gt; None
  | hd :: tl -&gt; <span class="k">if</span> f hd <span class="k">then</span> Some hd <span class="k">else</span> find_alt f tl

<span class="k">let</span> <span class="k">rec</span> find_alt_ok #a (f:a -&gt; bool) (l:list a)
  : <span class="k">Lemma</span> (<span class="k">match</span> find_alt f l <span class="k">with</span>
           | Some x -&gt; f x
           | <span class="k">_</span> -&gt; <span class="k">true</span>)
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; ()
    | <span class="k">_</span> :: tl -&gt; find_alt_ok f tl
</pre></div>
</div>
</div>
</section>
<section id="exercise-fold-left">
<h3>演習：fold_left<a class="headerlink" href="#exercise-fold-left" title="Link to this heading"></a></h3>
<p>以下に <code class="docutils literal notranslate"><span class="pre">fold_left</span></code> 関数を示します。:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fold_left</span> <span class="n">f</span> <span class="p">[</span><span class="n">b1</span><span class="p">;</span> <span class="o">...</span><span class="p">;</span> <span class="n">bn</span><span class="p">]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="o">...</span> <span class="p">(</span><span class="n">f</span> <span class="n">b2</span> <span class="p">(</span><span class="n">f</span> <span class="n">b1</span> <span class="n">a</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> fold_left #a #b (f: b -&gt; a -&gt; a) (l: list b) (acc:a)
  : a
  = <span class="k">match</span> l <span class="k">with</span>
    | [] -&gt; acc
    | hd :: tl -&gt; fold_left f tl (f hd acc)
</pre></div>
</div>
<p>次の補題を証明しなさい。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> fold_left_Cons_is_rev (#a:Type) (l:list a)
  : <span class="k">Lemma</span> (fold_left Cons l [] == reverse l)
</pre></div>
</div>
<div class="toggle docutils container">
<div class="header docutils container">
<dl class="simple">
<dt>ヒント：この証明は、これまでより一段階難しいです。</dt><dd><p>帰納法の仮定を強める必要があり、<code class="docutils literal notranslate"><span class="pre">append</span></code> の結合則や <code class="docutils literal notranslate"><span class="pre">append</span> <span class="pre">l</span> <span class="pre">[]</span> <span class="pre">==</span> <span class="pre">l</span></code> も証明する必要があるかもしれません。</p>
</dd>
</dl>
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> append_assoc #a (l1 l2 l3 : list a)
  : <span class="k">Lemma</span> (append l1 (append l2 l3) == append (append l1 l2) l3)
  = <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; ()
    | h1 :: t1 -&gt; append_assoc t1 l2 l3

<span class="k">let</span> <span class="k">rec</span> fold_left_Cons_is_rev_stronger #a (l1 l2: list a)
  : <span class="k">Lemma</span> (fold_left Cons l1 l2 == append (reverse l1) l2)
  = <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; ()
    | h1 :: t1 -&gt;
      <span class="c">// (1) [append (append (reverse t1) [h1]) l2</span>
      <span class="c">//      == append (reverse t1) (append [h1] l2)]</span>
      append_assoc (reverse t1) [h1] l2;
      <span class="c">// (2) [fold_left Cons t1 (h1 :: l2) = append (reverse t1) (h1 :: l2)]</span>
      fold_left_Cons_is_rev_stronger t1 (h1 :: l2)
      <span class="c">// append (reverse l1) l2</span>
      <span class="c">// =def= append (append (reverse t1) [h1]) l2</span>
      <span class="c">// =(1)= append (reverse t1) (append [h1] l2)</span>
      <span class="c">// =def= append (reverse t1) (h1 :: l2)</span>
      <span class="c">// =(2)= fold_left Cons t1 (h1 :: l2)</span>
      <span class="c">// =def= fold_left Cons l1 l2</span>

<span class="k">let</span> <span class="k">rec</span> append_right_unit #a (l1:list a)
  : <span class="k">Lemma</span> (append l1 [] == l1)
  = <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; ()
    | <span class="k">_</span> :: tl -&gt; append_right_unit tl

<span class="k">let</span> fold_left_Cons_is_rev #a (l:list a)
  : <span class="k">Lemma</span> (fold_left Cons l [] == reverse l)
  = fold_left_Cons_is_rev_stronger l [];
    append_right_unit (reverse l)
</pre></div>
</div>
</div>
</section>
</section>
</section>


           </div>
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="part1_termination.html" class="btn btn-neutral float-left" title="停止性の証明" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="part1_quicksort.html" class="btn btn-neutral float-right" title="ケーススタディ：クイックソート" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>