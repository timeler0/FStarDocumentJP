

<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>消去とゴースト効果 &mdash; Proof-Oriented Programming in F*  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=24463673" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c033477b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=4755f45a"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="発散（非停止）" href="part4_div.html" />
    <link rel="prev" title="Total な計算の効果" href="part4_computation_types_and_tot.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Proof-Oriented Programming in F*
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../structure.html">本書の構成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/part1.html">全域関数によるプログラミングと証明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part2/part2.html">帰納的型によるデータ・証明・計算の表現</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part3/part3.html">インターフェースと型クラスによるモジュール性</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part4.html">計算効果</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="part4_background.html">依存関係を追跡する計算型</a></li>
<li class="toctree-l2"><a class="reference internal" href="part4_computation_types_and_tot.html">Total な計算の効果</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">消去とゴースト効果</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ghost-a-primitive-effect">Ghost：プリミティブな効果</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ghost-computations-as-specifications">仕様としてのゴースト計算</a></li>
<li class="toctree-l3"><a class="reference internal" href="#erasable-and-non-informative-types">消去可能型と非情報型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-erased-type-reveal-and-hide"><code class="docutils literal notranslate"><span class="pre">erased</span></code> 型、<code class="docutils literal notranslate"><span class="pre">reveal</span></code>、<code class="docutils literal notranslate"><span class="pre">hide</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-ghost-computations-in-total-contexts">Total 文脈でゴースト計算を使う</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#effect-promotion-for-non-informative-types">非情報型に対する効果昇格</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#revisiting-vector-concatenation">ベクタ連結を振り返る</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="part4_div.html">発散（非停止）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part4_pure.html">プリミティブ効果の精錬（リファインメント）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part5/part5.html">Meta-F* によるタクティクスとメタプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/pulse.html">Pulse: 並行分離論理における証明指向プログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../under_the_hood/under_the_hood.html">内部の仕組み</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part4.html">計算効果</a></li>
      <li class="breadcrumb-item active">消去とゴースト効果</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <section id="erasure-and-the-ghost-effect">
<span id="part4-ghost"></span><h1>消去とゴースト効果<a class="headerlink" href="#erasure-and-the-ghost-effect" title="Link to this heading"></a></h1>
<p>証明指向のプログラムを書くと、実行されるコードについての性質を述べたり証明したりするだけの部分が必ず出てきます。本章で扱う最初の非自明な効果は、計算的に関係のある部分と、計算的には無関係（仕様用、すなわち <em>ゴースト</em>）な部分を分離します。この分離により、F* コンパイラはプログラム中のゴースト部分を完全に最適化で取り除けることを保証します。</p>
<p>ここで何を目指すのかを掴むため、長さ付き（インデックス付き）ベクタをもう一度見てみましょう——最初に <a class="reference internal" href="../part2/part2_vectors.html#part2-vectors"><span class="std std-ref">こちら</span></a> で登場しました。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> vec (a:Type) : nat -&gt; Type =
  | Nil : vec a 0
  | Cons : #n:nat -&gt; hd:a -&gt; tl:vec a n -&gt; vec a (n + 1)
</pre></div>
</div>
<p>そして 2 つのベクタを連結する関数：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> append #a #n #m (v1:vec a n) (v2:vec a m)
  : vec a (n + m)
  = <span class="k">match</span> v1 <span class="k">with</span>
    | Nil -&gt; v2
    | Cons hd tl -&gt; Cons hd (append tl v2)
</pre></div>
</div>
<p>これを 2 つのリスト連結と比べてみます：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> list_append #a (l1 l2:list a) =
    <span class="k">match</span> l1 <span class="k">with</span>
    | [] -&gt; []
    | hd::tl -&gt; hd :: list_append tl l2
</pre></div>
</div>
<p>見た目には、暗黙引数のおかげで、ベクタの <code class="docutils literal notranslate"><span class="pre">append</span></code> もリスト連結と同程度に効率的に思えるかもしれません——長さインデックスがオーバーヘッドを課していないように見えるためです。しかし、F* が長さ付きベクタを OCaml に抽出したコードを見てみましょう。</p>
<p>まず <code class="docutils literal notranslate"><span class="pre">vec</span></code> 型の定義では、OCaml は依存型でないため、F* の <code class="docutils literal notranslate"><span class="pre">nat</span></code> インデックスは <code class="docutils literal notranslate"><span class="pre">'dummy</span></code> 型引数に置き換えられます——ここまでは問題ありません。しかし <code class="docutils literal notranslate"><span class="pre">Cons</span></code> コンストラクタは 3 つのフィールドを持ちます：末尾の長さを表す <code class="docutils literal notranslate"><span class="pre">Prims.nat</span></code>、先頭要素、そして末尾。つまり各 <code class="docutils literal notranslate"><span class="pre">Cons</span></code> で末尾の長さが保持され、通常の <code class="docutils literal notranslate"><span class="pre">list</span></code> よりも実際には空間効率が悪くなります。</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">dummy</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Nil</span> 
  <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="nn">Prims</span><span class="p">.</span><span class="n">nat</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span>
</pre></div>
</div>
<p>次に OCaml の <code class="docutils literal notranslate"><span class="pre">append</span></code> 定義では、ベクタの長さ用に追加引数 <code class="docutils literal notranslate"><span class="pre">n</span></code> と <code class="docutils literal notranslate"><span class="pre">m</span></code> を受け取り、さらに最後のケースでは結果ベクタを構築する際に <code class="docutils literal notranslate"><span class="pre">n'</span> <span class="pre">+</span> <span class="pre">m</span></code> の加算も発生します。したがって <code class="docutils literal notranslate"><span class="pre">append</span></code> は時間効率の面でも <code class="docutils literal notranslate"><span class="pre">List.append</span></code> より劣ります。</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">append</span> <span class="o">:</span>
  <span class="k">&#39;</span><span class="n">a</span> <span class="o">.</span>
    <span class="nn">Prims</span><span class="p">.</span><span class="n">nat</span> <span class="o">-&gt;</span>
      <span class="nn">Prims</span><span class="p">.</span><span class="n">nat</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span>
  <span class="o">=</span>
  <span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span>
    <span class="k">fun</span> <span class="n">m</span> <span class="o">-&gt;</span>
      <span class="k">fun</span> <span class="n">v1</span> <span class="o">-&gt;</span>
        <span class="k">fun</span> <span class="n">v2</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="n">v1</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Nil</span> <span class="o">-&gt;</span> <span class="n">v2</span>
          <span class="o">|</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">n&#39;</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="o">-&gt;</span>
              <span class="nc">Cons</span> <span class="o">((</span><span class="n">n&#39;</span> <span class="o">+</span> <span class="n">m</span><span class="o">),</span> <span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">append</span> <span class="n">n&#39;</span> <span class="n">m</span> <span class="n">tl</span> <span class="n">v2</span><span class="o">))</span>
</pre></div>
</div>
<p>これは特に残念です。というのも <code class="docutils literal notranslate"><span class="pre">append</span></code> の計算的挙動は実際には入力ベクタの長さインデックスに依存していないからです。必要なのは、「計算の一部は仕様・証明のためだけに存在し、プログラムの観測可能な結果を変えずにコンパイル時に取り除ける」と F* コンパイラに示す方法です。これが <em>消去（erasure）</em> の役割——コンパイルのために計算的に無関係な部分を取り除くことです。</p>
<p>以下は <code class="docutils literal notranslate"><span class="pre">FStar.Ghost</span></code> ライブラリの <code class="docutils literal notranslate"><span class="pre">erased</span></code> 型を用いて、コンパイラが消去すべき部分を F* に示す改訂版のベクタです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> VecErased
<span class="k">open</span> FStar.Ghost

<span class="k">noeq</span>
<span class="k">type</span> vec a : nat -&gt; Type = 
  | Nil : vec a 0
  | Cons : #n:erased nat -&gt; hd:a -&gt; tl:vec a n -&gt; vec a (n + 1)

<span class="k">let</span> <span class="k">rec</span> append #a (#n #m:erased nat) (v0:vec a n) (v1:vec a m)
  : vec a (n + m)
  = <span class="k">match</span> v0 <span class="k">with</span>   
    | Nil -&gt; v1
    | Cons hd tl -&gt; Cons hd (append tl v1)
</pre></div>
</div>
<p>詳細は後で述べますが、ここでは次の点に注目してください：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cons</span></code> の最初の引数は <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> 型になっています。</p></li>
<li><p>入力ベクタのインデックスに対応する <code class="docutils literal notranslate"><span class="pre">append</span></code> の暗黙引数も <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> 型です。</p></li>
</ol>
</div></blockquote>
<p>このコードを OCaml に抽出すると、次のようになります：</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">dummy</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Nil</span> 
  <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="kt">unit</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span>
</pre></div>
</div>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">append</span> <span class="o">:</span>
  <span class="k">&#39;</span><span class="n">a</span> <span class="o">.</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="kt">unit</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span>
    <span class="k">fun</span> <span class="n">m</span> <span class="o">-&gt;</span>
      <span class="k">fun</span> <span class="n">v0</span> <span class="o">-&gt;</span>
        <span class="k">fun</span> <span class="n">v1</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="n">v0</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Nil</span> <span class="o">-&gt;</span> <span class="n">v1</span>
          <span class="o">|</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">uu___</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Cons</span> <span class="o">(</span><span class="bp">()</span><span class="o">,</span> <span class="n">hd</span><span class="o">,</span> <span class="o">(</span><span class="n">append</span> <span class="bp">()</span> <span class="bp">()</span> <span class="n">tl</span> <span class="n">v1</span><span class="o">))</span>
</pre></div>
</div>
<p>消去対象の引数はすべて単位値 <code class="docutils literal notranslate"><span class="pre">()</span></code> に置き換わり、<code class="docutils literal notranslate"><span class="pre">append</span></code> における不要な加算も無くなっていることに注目してください。</p>
<p>もちろん、単位値を残さず引数自体を完全に消せればさらにきれいですが、これらの不要な単位は後段のコンパイラ（例：OCaml 本体）に除去を任せます。さらに、F* から抽出した ML コードを C に変換する場合は、KaRaMeL が生成する C コードからこれらの余分な単位を取り除きます。</p>
<section id="ghost-a-primitive-effect">
<h2>Ghost：プリミティブな効果<a class="headerlink" href="#ghost-a-primitive-effect" title="Link to this heading"></a></h2>
<p>F* の効果システムにおける 2 つ目のプリミティブ効果は <em>ゴースト</em> 計算、すなわち効果ラベルが <code class="docutils literal notranslate"><span class="pre">GTot</span></code> の計算型です。 <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <code class="docutils literal notranslate"><span class="pre">GTot</span></code> は効果階層で <code class="docutils literal notranslate"><span class="pre">Tot</span></code> より上（<code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">&lt;</span> <span class="pre">GTot</span></code>）です。つまり <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">t</span></code> の項は、型 <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">s</span></code> の項の挙動に影響を与えられません。逆に、すべての <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 計算は暗黙に <code class="docutils literal notranslate"><span class="pre">GTot</span></code> へ昇格できます。</p>
<p>ゴースト計算は純粋・全域の項と同様に扱いやすく、すべての入力で停止し、返り値以外の観測可能な効果は持ちません。このため F* の論理コアには <code class="docutils literal notranslate"><span class="pre">Tot</span></code> と <code class="docutils literal notranslate"><span class="pre">GTot</span></code> の両方が含まれます。<code class="docutils literal notranslate"><span class="pre">Tot</span></code> と <code class="docutils literal notranslate"><span class="pre">GTot</span></code> の違いが意味を持つのは、コンパイル時の扱いだけです。ゴースト計算はコンパイラによって必ず消去され、<code class="docutils literal notranslate"><span class="pre">Tot</span></code> 計算は保持されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">Tot</span></code> の項は暗黙に <code class="docutils literal notranslate"><span class="pre">GTot</span></code> へ昇格されるので、<code class="docutils literal notranslate"><span class="pre">GTot</span></code> の効果注釈を付けるだけで、そのコード片を消去対象に指定できます。例えば次はゴースト版の階乗です：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial (n:nat)
  : <span class="k">GTot</span> nat
  = <span class="k">if</span> n = 0 <span class="k">then</span> 1 <span class="k">else</span> n * factorial (n - 1)
</pre></div>
</div>
<p>定義は先に見た total 版と同一ですが、戻りの計算型に <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">nat</span></code> を注釈した点だけが異なります。これにより F* は <code class="docutils literal notranslate"><span class="pre">factorial</span></code> をコンパイル時に消去すべきだと認識し、型・効果検査は <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 計算が <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">n</span></code> に依存できないことを保証します。</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">GTot</span></code> は “Ghost and Total” の略（発音は「ジートート」）ですが、直感的とは言い難い名前です。将来的に（<code class="docutils literal notranslate"><span class="pre">Spec</span></code>、<code class="docutils literal notranslate"><span class="pre">Ghost</span></code>、<code class="docutils literal notranslate"><span class="pre">Erased</span></code> などに）名称変更する予定ですが、既存の多くの F* コードに破壊的変更となります。</p>
</aside>
</aside>
</section>
<section id="ghost-computations-as-specifications">
<h2>仕様としてのゴースト計算<a class="headerlink" href="#ghost-computations-as-specifications" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">factorial</span></code> のようなゴースト関数は仕様に用いられます。例えば末尾再帰最適化した <code class="docutils literal notranslate"><span class="pre">factorial_tail</span></code> が <code class="docutils literal notranslate"><span class="pre">factorial</span></code> と等価であることを示す証明などです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_tail (n:nat) (out:nat)
  : <span class="k">Tot</span> (r:nat { r == out * factorial n })
  = <span class="k">if</span> n = 0 <span class="k">then</span> out
    <span class="k">else</span> factorial_tail (n - 1) (n * out)

<span class="k">let</span> fact (n:nat) 
  : <span class="k">Tot</span> (r:nat { r == factorial n })
  = factorial_tail n 1
</pre></div>
</div>
<p>この型により、利用者は効率の良い <code class="docutils literal notranslate"><span class="pre">fact</span></code> を使いながら、推論時には <code class="docutils literal notranslate"><span class="pre">fact</span></code> と同値であると証明された標準的な <code class="docutils literal notranslate"><span class="pre">factorial</span></code> を使えます。</p>
<p>一方、同じ仕様をゴースト関数 <code class="docutils literal notranslate"><span class="pre">factorial</span></code> を直接使って実装しようとすると、F* は効果の非互換エラーを報告します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span>[@@expect_failure]
<span class="k">let</span> factorial_bad (n:nat) (out:nat)
  : <span class="k">Tot</span> (r:nat { r == out * factorial n })
  = out * factorial n
</pre></div>
</div>
<p>エラーは：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Computed type &quot;r: nat{r == out * factorial n}&quot; and
effect &quot;GTot&quot; is not compatible with the annotated
type &quot;r: nat{r == out * factorial n}&quot; effect &quot;Tot&quot;
</pre></div>
</div>
<p>つまり F* は <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈でゴースト計算の使用を禁じますが、<code class="docutils literal notranslate"><span class="pre">r:nat</span> <span class="pre">{</span> <span class="pre">r</span> <span class="pre">==</span> <span class="pre">out</span> <span class="pre">*</span> <span class="pre">factorial</span> <span class="pre">n</span> <span class="pre">}</span></code> のように仕様中での利用は許します。なぜ許されるのか、この後で説明します。</p>
</section>
<section id="erasable-and-non-informative-types">
<h2>消去可能型と非情報型<a class="headerlink" href="#erasable-and-non-informative-types" title="Link to this heading"></a></h2>
<p>消去対象の計算を分類する <code class="docutils literal notranslate"><span class="pre">GTot</span></code> 効果に加えて、F* では特定の <em>値型</em> 自体を消去可能として印を付ける方法も提供します。</p>
<p>証明項だけを表し、実行時オーバーヘッドを生まないようにしたい帰納的型を導入することを考えます。Coq では命題の型 <code class="docutils literal notranslate"><span class="pre">Prop</span></code> がこの役割を果たしますが、F* の <code class="docutils literal notranslate"><span class="pre">prop</span></code> は性質が異なります。その代わりに F* では、帰納的型定義に <code class="docutils literal notranslate"><span class="pre">erasable</span></code> 属性を付けられます。</p>
<p>例えば <a class="reference internal" href="../part2/part2_stlc.html#part2-stlc-typing"><span class="std std-ref">単純型付きラムダ計算（STLC）</span></a> を見たとき、STLC 項の型付け導出を表す次の帰納的型を導入しました。STLC の型検査器を定義し、以下の型を与えることで正しさを示せます：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> check (g:env) (e:exp) : (t : typ &amp; typing g e t)
</pre></div>
</div>
<p>しかしこの関数は、<code class="docutils literal notranslate"><span class="pre">e</span></code> の計算された型 <code class="docutils literal notranslate"><span class="pre">t:typ</span></code> に加えて型付け導出も返します。型付け導出が有用な場合もありますが、しばしば返す必要はありません。そこで以下のように <code class="docutils literal notranslate"><span class="pre">typing</span></code> 帰納型の定義に印を付け（他はそのまま）、コンパイラが <code class="docutils literal notranslate"><span class="pre">typing</span> <span class="pre">g</span> <span class="pre">e</span> <span class="pre">t</span></code> を <code class="docutils literal notranslate"><span class="pre">unit</span></code> 型に抽出し、その値がすべて単位値 <code class="docutils literal notranslate"><span class="pre">()</span></code> に消去されることを F* が保証するようにできます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span>[@@erasable]
<span class="k">noeq</span>
<span class="k">type</span> typing : env -&gt; exp -&gt; typ -&gt; Type = ...
</pre></div>
</div>
<p>型に <code class="docutils literal notranslate"><span class="pre">erasable</span></code> 属性を付け、<code class="docutils literal notranslate"><span class="pre">unit</span></code> へ消去しても安全なのは、F* が消去可能型の利用法を制限しているからです。特に、<code class="docutils literal notranslate"><span class="pre">Tot</span></code> 計算が消去可能型の値から情報を取り出すことはできません。</p>
<p>消去可能型に密接に関連する概念として <em>非情報型</em> があり、次のように帰納的に定義されます：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span></code> は非情報型である</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prop</span></code> は非情報型である（すなわち <code class="docutils literal notranslate"><span class="pre">unit</span></code> とそのすべての部分型）</p></li>
<li><p>消去可能型は非情報型である</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">-&gt;</span> <span class="pre">Tot</span> <span class="pre">s</span></code> は、<code class="docutils literal notranslate"><span class="pre">s</span></code> が非情報型なら非情報型である</p></li>
<li><p>ゴースト関数型 <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">-&gt;</span> <span class="pre">GTot</span> <span class="pre">s</span></code> は非情報型である</p></li>
<li><p>ユーザ定義計算型 <code class="docutils literal notranslate"><span class="pre">C</span></code> を持つ関数型 <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code> は、<code class="docutils literal notranslate"><span class="pre">C</span></code> の効果ラベルに erasable 属性があれば非情報型である。</p></li>
</ol>
</div></blockquote>
<p>直観的には、非情報型とは <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈で場合分け（パターンマッチ）できない型のことです。</p>
<p>非情報型の概念を用いると、<code class="docutils literal notranslate"><span class="pre">erasable</span></code> 型に対する制約を次のように定義できます：</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>消去可能型に対してパターンマッチする計算は、戻り型が非情報型でなければならない。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">erasable</span></code> 属性を持つ帰納的型は組み込みの可判定同値を持たず、<code class="docutils literal notranslate"><span class="pre">noeq</span></code> も付けなければならない。</p></li>
</ol>
</div></blockquote>
</section>
<section id="the-erased-type-reveal-and-hide">
<h2><code class="docutils literal notranslate"><span class="pre">erased</span></code> 型、<code class="docutils literal notranslate"><span class="pre">reveal</span></code>、<code class="docutils literal notranslate"><span class="pre">hide</span></code><a class="headerlink" href="#the-erased-type-reveal-and-hide" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">erasable</span></code> 属性は新しい帰納的型定義にのみ付けることができ、その型のすべての出現が消去可能になります。<code class="docutils literal notranslate"><span class="pre">nat</span></code> のように消去可能でない型でも、一部の出現（例：<code class="docutils literal notranslate"><span class="pre">Vector.append</span></code> の引数）だけ消去したい場合、標準ライブラリ <code class="docutils literal notranslate"><span class="pre">FStar.Ghost.fsti</span></code> が次を提供します：</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="c">(** [erased t] is the computationally irrelevant counterpart of [t] *)</span>
[@@ erasable]
<span class="k">val</span> erased (t:Type u#a) : Type u#a
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FStar.Ghost</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span></code> と <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">a</span></code> の間の全単射を与える <code class="docutils literal notranslate"><span class="pre">reveal</span></code> / <code class="docutils literal notranslate"><span class="pre">hide</span></code> も提供します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> reveal (#a: Type u#a) (v:erased a) : <span class="k">GTot</span> a

<span class="k">val</span> hide (#a: Type u#a) (v:a) : <span class="k">Tot</span> (erased a)

<span class="k">val</span> hide_reveal (#a: Type) (x: erased a)
  : <span class="k">Lemma</span> (<span class="k">ensures</span> (hide (reveal x) == x))
          [<span class="k">SMTPat</span> (reveal x)]

<span class="k">val</span> reveal_hide (#a: Type) (x: a)
  : <span class="k">Lemma</span> (<span class="k">ensures</span> (reveal (hide x) == x))
          [<span class="k">SMTPat</span> (hide x)]
</pre></div>
</div>
<p>重要なのは、<code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">v</span></code> は <code class="docutils literal notranslate"><span class="pre">v:erased</span> <span class="pre">a</span></code> の抽象を破って素の <code class="docutils literal notranslate"><span class="pre">a</span></code> を返しますが、その際に <code class="docutils literal notranslate"><span class="pre">GTot</span></code> 効果が発生することです——したがって <code class="docutils literal notranslate"><span class="pre">reveal</span></code> は任意の <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈では使えません。</p>
<p>双対的に、<code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">v</span></code> は <code class="docutils literal notranslate"><span class="pre">v:a</span></code> を消去できます。<code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈は <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">a</span></code> の値に依存できないからです。</p>
<p>2 つの補題に付けた SMT パターンにより、F* と Z3 は値とその隠された対応物を関連付けるために自動で補題をインスタンス化できます——SMT パターンの詳細は <a class="reference internal" href="../under_the_hood/uth_smt.html#uth-smt"><span class="std std-ref">この章</span></a> を参照してください。</p>
<p><strong>暗黙の強制（coercion）</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">FStar.Ghost.erased</span></code>、<code class="docutils literal notranslate"><span class="pre">reveal</span></code>、<code class="docutils literal notranslate"><span class="pre">hide</span></code> は F* で非常によく使われるため、コンパイラは特別な支援を提供します。具体的には、<code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">t</span></code> が期待される文脈で <code class="docutils literal notranslate"><span class="pre">v:t</span></code> を使うと、F* は暗黙に <code class="docutils literal notranslate"><span class="pre">v</span></code> を <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">v</span></code> へ強制します。逆に <code class="docutils literal notranslate"><span class="pre">t</span></code> が期待されるのに <code class="docutils literal notranslate"><span class="pre">v:erased</span> <span class="pre">t</span></code> が与えられた場合は、暗黙に <code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">v</span></code> に強制します。</p>
<p>以下の例は使用法と制限をいくつか示します。<code class="docutils literal notranslate"><span class="pre">--dump_module</span> <span class="pre">RevealHideCoercions</span> <span class="pre">--print_implicits</span></code> を使うと、暗黙引数を展開したコードを F* に出力させられます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> RevealHideCoercions
<span class="k">open</span> FStar.Ghost

<span class="k">let</span> auto_hide (x:nat) : erased nat = x
<span class="k">let</span> auto_reveal (x:erased nat) : <span class="k">GTot</span> nat = x

[@@expect_failure] <span class="c">//Expect GTot</span>
<span class="k">let</span> auto_reveal_2 (x:erased nat) : <span class="k">Tot</span> nat = x

<span class="k">let</span> incr (x:nat) : nat = x + 1
<span class="k">let</span> incr_e (x:erased nat) : erased nat = incr x

<span class="k">let</span> incr&#39; (x:nat) : <span class="k">GTot</span> nat = incr_e x

[@@expect_failure]
<span class="k">let</span> poly (x:nat) (y:erased nat) = x == y
</pre></div>
</div>
<p>いくつか補足します：</p>
<ul class="simple">
<li><p>最初の 2 つの関数は、<code class="docutils literal notranslate"><span class="pre">nat</span></code> がどのように暗黙に <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> に強制されるかを示します。なお <code class="docutils literal notranslate"><span class="pre">auto_reveal</span></code> の効果は <code class="docutils literal notranslate"><span class="pre">GTot</span></code> です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto_reveal_2</span></code> は失敗します。注釈が誤って効果ラベルを <code class="docutils literal notranslate"><span class="pre">Tot</span></code> と主張しているためです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">incr</span></code> は単なる <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">-&gt;</span> <span class="pre">nat</span></code> 関数です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">incr_e</span></code> は興味深く、<code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> を <code class="docutils literal notranslate"><span class="pre">incr</span></code> に渡し、注釈も <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> を期待します。本体は暗黙に <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(incr</span> <span class="pre">(reveal</span> <span class="pre">x))</span></code> に強制されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">incr'</span></code> は <code class="docutils literal notranslate"><span class="pre">incr_e</span></code> を呼ぶため、本体は暗黙に <code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">(incr_e</span> <span class="pre">(hide</span> <span class="pre">x))</span></code> に強制されます。</p></li>
<li><p>最後に <code class="docutils literal notranslate"><span class="pre">poly</span></code> は暗黙強制の限界を示します：F* が強制を挿入するのは、期待型と項の型が <code class="docutils literal notranslate"><span class="pre">erased</span></code> コンストラクタでのみ異なる場合です。<code class="docutils literal notranslate"><span class="pre">poly</span></code> では <code class="docutils literal notranslate"><span class="pre">==</span></code> が多相なため、文脈の期待型は未解決の単一化変数に過ぎず、強制は挿入されません。その代わり、<code class="docutils literal notranslate"><span class="pre">nat</span></code> が期待されているのに <code class="docutils literal notranslate"><span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> だと F* は文句を言います。</p></li>
</ul>
</section>
<section id="using-ghost-computations-in-total-contexts">
<span id="ghost-in-total-contexts"></span><h2>Total 文脈でゴースト計算を使う<a class="headerlink" href="#using-ghost-computations-in-total-contexts" title="Link to this heading"></a></h2>
<p>既に <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">&lt;</span> <span class="pre">GTot</span></code> であることを述べ、<code class="docutils literal notranslate"><span class="pre">Tot</span></code> 計算を <code class="docutils literal notranslate"><span class="pre">GTot</span></code> 文脈で再利用できることを見ました。消去の健全性のためには、<code class="docutils literal notranslate"><span class="pre">GTot</span></code> の項を <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈で使えないことが重要で、実際 F* は一般には禁止します。しかし 1 つだけ例外があり、<code class="docutils literal notranslate"><span class="pre">Ghost.erased</span></code> で包まずに <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 文脈から <code class="docutils literal notranslate"><span class="pre">GTot</span></code> 計算を直接呼べる場合があります。</p>
<section id="effect-promotion-for-non-informative-types">
<h3>非情報型に対する効果昇格<a class="headerlink" href="#effect-promotion-for-non-informative-types" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">s</span></code> 型の項 <code class="docutils literal notranslate"><span class="pre">f</span></code> を考え、<code class="docutils literal notranslate"><span class="pre">s</span></code> が非情報型だとします。<code class="docutils literal notranslate"><span class="pre">s</span></code> は非情報型なので、total 文脈は <code class="docutils literal notranslate"><span class="pre">f</span></code> から情報を取り出せません。そのため F* は、<code class="docutils literal notranslate"><span class="pre">s</span></code> が非情報型であれば <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">s</span></code> を暗黙に <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">s</span></code> へ昇格することを許します。</p>
<p>例えば <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(factorial</span> <span class="pre">0)</span> <span class="pre">:</span> <span class="pre">Tot</span> <span class="pre">(erased</span> <span class="pre">nat)</span></code> は導けます。詳細に追ってみましょう。</p>
<ol class="arabic simple">
<li><p>まず <code class="docutils literal notranslate"><span class="pre">factorial</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">GTot</span> <span class="pre">nat</span></code> です。</p></li>
<li><p><a class="reference internal" href="part4_computation_types_and_tot.html#part4-evaluation-order"><span class="std std-ref">評価順序</span></a> と効果付き引数への関数適用の議論を思い出すと、<code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(factorial</span> <span class="pre">0)</span></code> は <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">factorial</span> <span class="pre">0</span> <span class="pre">in</span> <span class="pre">hide</span> <span class="pre">x</span></code> と同値で、ここで <code class="docutils literal notranslate"><span class="pre">x:nat</span></code>、<code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">Tot</span> <span class="pre">(erased</span> <span class="pre">nat)</span></code> です。</p></li>
<li><p>効果付き項の逐次合成の規則より、<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">factorial</span> <span class="pre">0</span> <span class="pre">in</span> <span class="pre">hide</span> <span class="pre">x</span></code> の型は <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">(erased</span> <span class="pre">nat)</span></code> になります（<code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">=</span> <span class="pre">lub</span> <span class="pre">GTot</span> <span class="pre">Tot</span></code>）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">erased</span> <span class="pre">nat</span></code> は非情報型なので、<code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">(erased</span> <span class="pre">nat)</span></code> は <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">(erased</span> <span class="pre">nat)</span></code> に昇格し、これが <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(factorial</span> <span class="pre">0)</span></code> の型になります。</p></li>
</ol>
<p>非情報型を返すゴースト関数の効果昇格は非常に有用です。ゴースト部分計算の結果を消去型で隠す限り、total 計算と混在させられます。例えば下のコードでは <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(factorial</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1))</span></code> を用い、その結果 <code class="docutils literal notranslate"><span class="pre">f_n_1</span></code> をアサートや他の証明ステップで利用しますが、関数自体は <code class="docutils literal notranslate"><span class="pre">Tot</span></code> 効果のままです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> factorial_tail_alt (n:nat) (out:nat)
  : <span class="k">Tot</span> (r:nat { r == out * factorial n })
  = <span class="k">if</span> n = 0 <span class="k">then</span> out
    <span class="k">else</span> (
      <span class="k">let</span> f_n_1 = hide (factorial (n - 1)) <span class="k">in</span>
      <span class="k">let</span> result = factorial_tail_alt (n - 1) (n * out) <span class="k">in</span>
      <span class="k">assert</span> (result == (n * out) * f_n_1);
      result
    )
</pre></div>
</div>
</section>
</section>
<section id="revisiting-vector-concatenation">
<h2>ベクタ連結を振り返る<a class="headerlink" href="#revisiting-vector-concatenation" title="Link to this heading"></a></h2>
<p>これで本章冒頭のベクタ連結の例がどのように機能するかを理解するための材料が揃いました。以下に暗黙引数や reveal/hide をすべて明示した版を示します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> VecErasedExplicit
<span class="k">open</span> FStar.Ghost

<span class="k">noeq</span>
<span class="k">type</span> vec a : nat -&gt; Type = 
  | Nil : vec a 0
  | Cons : #n:erased nat -&gt; hd:a -&gt; tl:vec a (reveal n) -&gt; vec a (reveal n + 1)

<span class="k">let</span> <span class="k">rec</span> append #a (#n #m:erased nat) (v0:vec a (reveal n)) (v1:vec a (reveal m))
  : <span class="k">Tot</span> (vec a (reveal n + reveal m))
        (<span class="k">decreases</span> (reveal n))
  = <span class="k">match</span> v0 <span class="k">with</span>   
    | Nil -&gt; v1
    | Cons #<span class="k">_</span> #n_tl hd tl -&gt;
      Cons #a 
           #(hide (reveal n_tl + reveal m))
           hd 
           (append #a 
                   #n_tl
                   #m
                   tl
                   v1)
</pre></div>
</div>
<p><strong>vec の定義</strong></p>
<p>帰納的型 <code class="docutils literal notranslate"><span class="pre">vec</span> <span class="pre">a</span></code> の定義では、<code class="docutils literal notranslate"><span class="pre">reveal</span></code> が 2 回現れます。ベクタの <code class="docutils literal notranslate"><span class="pre">tl</span></code> の型である <code class="docutils literal notranslate"><span class="pre">vec</span> <span class="pre">a</span> <span class="pre">(reveal</span> <span class="pre">n)</span></code> を考えます。<code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">n</span></code> は <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">nat</span></code> のゴースト計算なので <code class="docutils literal notranslate"><span class="pre">vec</span> <span class="pre">a</span> <span class="pre">(reveal</span> <span class="pre">n)</span> <span class="pre">:</span> <span class="pre">GTot</span> <span class="pre">Type</span></code> です。しかし <code class="docutils literal notranslate"><span class="pre">Type</span></code> は非情報型なので <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">Type</span></code> は <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">Type</span></code> へ昇格します。この <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">Type</span></code> から <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">Type</span></code> への昇格は F* 全体で一般的で、型や仕様内でゴースト計算を自由に使えるようにします。</p>
<p><code class="docutils literal notranslate"><span class="pre">Cons</span></code> の結果型にある <code class="docutils literal notranslate"><span class="pre">vec</span> <span class="pre">a</span> <span class="pre">(reveal</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1)</span></code> も同様です。<code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> は <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">nat</span></code> ですが、これを <code class="docutils literal notranslate"><span class="pre">vec</span> <span class="pre">a</span></code> に適用すると <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">Type</span></code> になり、<code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">Type</span></code> に昇格します。</p>
<p><strong>append の型</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">append</span></code> の型には 4 つの <code class="docutils literal notranslate"><span class="pre">reveal</span></code> があり、そのうち <code class="docutils literal notranslate"><span class="pre">v0</span></code>、<code class="docutils literal notranslate"><span class="pre">v1</span></code>、戻り型の 3 つは <code class="docutils literal notranslate"><span class="pre">Cons</span></code> のフィールドと同様に <code class="docutils literal notranslate"><span class="pre">GTot</span> <span class="pre">Type</span></code> が <code class="docutils literal notranslate"><span class="pre">Tot</span> <span class="pre">Type</span></code> に昇格します。</p>
<p>もう 1 点、減少性（decreases）節では <code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">n</span></code> を明示しています。各再帰呼び出しで減少するのは <code class="docutils literal notranslate"><span class="pre">n</span></code> 自身ではなく、<code class="docutils literal notranslate"><span class="pre">n</span></code> と全単射な <code class="docutils literal notranslate"><span class="pre">nat</span></code> だからです。F* が関数の減少性節を推論する際、その節に含まれる消去項は自動的に reveal されます。</p>
<p><strong>append の定義</strong></p>
<p>再帰呼び出しでは、インデックス引数を <code class="docutils literal notranslate"><span class="pre">n_tl</span></code> と <code class="docutils literal notranslate"><span class="pre">m</span></code> に具体化し、いずれも消去されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">Cons</span></code> ノードを構築する際、インデックス引数は <code class="docutils literal notranslate"><span class="pre">hide</span> <span class="pre">(reveal</span> <span class="pre">n_tl</span> <span class="pre">+</span> <span class="pre">reveal</span> <span class="pre">m)</span></code> に具体化されます。不要な加算は <code class="docutils literal notranslate"><span class="pre">hide</span></code> でマークされ、コンパイラが消去できるようになります。<code class="docutils literal notranslate"><span class="pre">factorial_tail_alt</span></code> で見たように、<code class="docutils literal notranslate"><span class="pre">hide</span></code> により ゴースト計算（<code class="docutils literal notranslate"><span class="pre">(reveal</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1)</span></code> など）を、仕様や証明のために必要な範囲で total 計算へ混在させられます。</p>
<p>ここまで非常に露骨に書きましたが、実際には F* が reveal/hide の暗黙強制を挿入してくれるため、実用上はだいぶ滑らかに書けます。</p>
</section>
</section>


           </div>
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="part4_computation_types_and_tot.html" class="btn btn-neutral float-left" title="Total な計算の効果" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="part4_div.html" class="btn btn-neutral float-right" title="発散（非停止）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>