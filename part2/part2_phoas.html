

<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>高階抽象構文（HOAS） &mdash; Proof-Oriented Programming in F*  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=24463673" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c033477b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=4755f45a"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="良基底関係と停止性" href="part2_well_founded.html" />
    <link rel="prev" title="単純型付きラムダ計算（STLC）" href="part2_stlc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Proof-Oriented Programming in F*
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../structure.html">本書の構成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/part1.html">全域関数によるプログラミングと証明</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part2.html">帰納的型によるデータ・証明・計算の表現</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="part2_inductive_type_families.html">帰納的型の定義</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_vectors.html">長さインデックス付きリスト</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_merkle.html">Merkle 木</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_equality.html">等式型</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_logical_connectives.html">構成的連言と古典的連言（論理結合子）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_stlc.html">単純型付きラムダ計算（STLC）</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">高階抽象構文（HOAS）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#roadmap">ロードマップ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#denotation-of-types">型の意味付け</a></li>
<li class="toctree-l3"><a class="reference internal" href="#term-representation">項の表現</a></li>
<li class="toctree-l3"><a class="reference internal" href="#denotation-of-terms">項の意味付け</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#termination">停止性</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">演習</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="part2_well_founded.html">良基底関係と停止性</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_par.html">計算効果の最初のモデル</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_universes.html">ユニバース（Universes）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part3/part3.html">インターフェースと型クラスによるモジュール性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part4/part4.html">計算効果</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part5/part5.html">Meta-F* によるタクティクスとメタプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/pulse.html">Pulse: 並行分離論理における証明指向プログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../under_the_hood/under_the_hood.html">内部の仕組み</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part2.html">帰納的型によるデータ・証明・計算の表現</a></li>
      <li class="breadcrumb-item active">高階抽象構文（HOAS）</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <section id="higher-order-abstract-syntax">
<span id="part2-phoas"></span><h1>高階抽象構文（HOAS）<a class="headerlink" href="#higher-order-abstract-syntax" title="Link to this heading"></a></h1>
<p>前章では、単純型付きラムダ計算（STLC）の <em>深い埋め込み（deep embedding）</em> を扱いました。ここでの「深い」とは、F★ の帰納的型でラムダ計算の <em>構文</em> を表現し、その意味論を F★ 内で数学的に定義して性質を証明した、という意味です。</p>
<p>STLC のような言語を F★ に埋め込む別の方法は、<em>浅い埋め込み（shallow embedding）</em> です。F★ 自身が関数型言語であり、単純型付き項を表現するには十分強力な型システムを持っています。そこで、STLC の抽象構文を F★ に符号化するだけでなく、F★ のラムダ式そのもので STLC を表現します。この種の符号化を浅い埋め込みと呼び、ホスト（メタ）言語（ここでは F★）の意味的構成要素で、埋め込み対象（オブジェクト）言語（本例では STLC）の対応する機能を表します。</p>
<p>本章では、この目的のための特に洗練された手法である <a href="#id1"><span class="problematic" id="id2">*</span></a>高階抽象構文*（HOAS）を扱います。背景については、<a class="reference external" href="http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08.pdf">Adam Chlipala の 2008 年の論文</a> が良い参考資料です（同論文ではより高度なパラメトリック版が展開されています）。</p>
<p>ここでの小さな事例研究では、非自明な添字を持つ帰納的型の活用、引数としての厳密に正の関数、そして少しの型レベル計算を含めつつ、HOAS の使い方を示します。</p>
<section id="roadmap">
<h2>ロードマップ<a class="headerlink" href="#roadmap" title="Link to this heading"></a></h2>
<p>以下の <code class="docutils literal notranslate"><span class="pre">typ</span></code> は、STLC のオブジェクト言語で用いる型を表します。具体的には基本型 <code class="docutils literal notranslate"><span class="pre">Bool</span></code> と <code class="docutils literal notranslate"><span class="pre">Int</span></code>、および関数型 <code class="docutils literal notranslate"><span class="pre">Arrow</span> <span class="pre">t1</span> <span class="pre">t2</span></code> です。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> typ =
  | Bool
  | Int
  | Arrow : typ -&gt; typ -&gt; typ
</pre></div>
</div>
<p>これは、前章の深い埋め込みにおける STLC 型の表現と対応しています。</p>
<p>興味深いのは、STLC の項とその意味論の表現です。目標を明確にすると、次を達成したいことになります。</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">:</span> <span class="pre">typ</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code> を定義し、STLC の型を F★ の型に解釈する。</p></li>
<li><p>型 <code class="docutils literal notranslate"><span class="pre">t:typ</span></code> を持つ型付き STLC 項を表す型 <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">t</span></code> を定義する。</p></li>
<li><p>STLC の項を適切な型の F★ の項へ解釈する関数 <code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">(#t:typ)</span> <span class="pre">(e:term</span> <span class="pre">t)</span> <span class="pre">:</span> <span class="pre">denote_typ</span> <span class="pre">t</span></code> を定義し、型 <code class="docutils literal notranslate"><span class="pre">t</span></code> のすべての正しく型付けされた STLC 項が、F★ で型 <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t</span></code> の関数として表現できることを示す。</p></li>
</ol>
</div></blockquote>
<p>この結果は、前章で示した型安全性（正しく型付けされたプログラムが常に進行できる）を包含するだけでなく、そのようなすべての項の簡約が必ず停止し、その意味を反映した F★ の値を生むことまで示します。</p>
</section>
<section id="denotation-of-types">
<span id="part2-phoas-denotation"></span><h2>型の意味付け<a class="headerlink" href="#denotation-of-types" title="Link to this heading"></a></h2>
<p>ロードマップのステップ 1 は、STLC の型 <code class="docutils literal notranslate"><span class="pre">typ</span></code> を F★ の型へ解釈することです。以下のように容易に定義できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> denote_typ (t:typ)
  : Type
  = <span class="k">match</span> t <span class="k">with</span>
    | Bool -&gt; bool
    | Int -&gt; int
    | Arrow t1 t2 -&gt; (denote_typ t1 -&gt; denote_typ t2)
</pre></div>
</div>
<p>ここでは、引数から <em>Type</em> を計算する再帰関数を定義しています。一見奇妙に見えるかもしれませんが、F★ のような依存型言語では正当です。</p>
<p><code class="docutils literal notranslate"><span class="pre">denote_typ</span></code> は、<code class="docutils literal notranslate"><span class="pre">Bool</span></code> と <code class="docutils literal notranslate"><span class="pre">Int</span></code> をそれぞれ F★ の <code class="docutils literal notranslate"><span class="pre">bool</span></code> と <code class="docutils literal notranslate"><span class="pre">int</span></code> に、<code class="docutils literal notranslate"><span class="pre">Arrow</span></code> を F★ の関数型に対応付けます。再帰呼び出しは引数の厳密な部分項に対して行われるため、関数は停止します。</p>
</section>
<section id="term-representation">
<h2>項の表現<a class="headerlink" href="#term-representation" title="Link to this heading"></a></h2>
<p>STLC（やラムダ的な変数束縛構造を持つ言語）を表現する主な難しさは、変数とその束縛子をどう表すかにあります。</p>
<p>前章の深い埋め込みでは、この問いへの答えは極めて構文的でした。変数をデ・ブライン指標で表し、各出現位置において、束縛子に到達するまでに通過するラムダの数を指標として数えました。</p>
<p>これに対し HOAS は全く異なるアプローチを取ります。ホスト言語（F★）にすでに存在する束縛構文や変数（すなわち F★ のラムダ項）を、オブジェクト言語（STLC）の束縛子や変数の表現に用いるのです。</p>
<p>項の表現で中心となる型は、以下で定義する <code class="docutils literal notranslate"><span class="pre">term</span></code> です。そこにはいくつか巧妙な工夫があり、順に簡潔に説明します。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">noeq</span>
<span class="k">type</span> term : typ -&gt; Type =
  | Var : #t:typ -&gt; denote_typ t -&gt; term t
  | TT  : term Bool
  | FF  : term Bool
  | I   : int -&gt; term Int
  | App : #t1:typ -&gt; #t2:typ -&gt;
          term (Arrow t1 t2) -&gt;
          term t1 -&gt;
          term t2
  | Lam : #t1:typ -&gt; #t2:typ -&gt;
          (denote_typ t1 -&gt; term t2) -&gt;
          term (Arrow t1 t2)
</pre></div>
</div>
<p>第一に、<code class="docutils literal notranslate"><span class="pre">term</span></code> 型は STLC の抽象構文と型付け規則の両方を同時に表現します。詳細は後述しますが、<code class="docutils literal notranslate"><span class="pre">term</span></code> は <code class="docutils literal notranslate"><span class="pre">t:typ</span></code> によって添字付けされ、符号化された STLC 項の型を示します。この添字構造が STLC の型付け規則を埋め込んでおり、正しく型付けされた項だけが構築できます。</p>
<p>第二に、構文の中で <code class="docutils literal notranslate"><span class="pre">denote_typ</span></code> を用いる点です。与えられた STLC 型 <code class="docutils literal notranslate"><span class="pre">t</span></code> の変数や束縛子は、対応する F★ 型 <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t</span></code> の変数・束縛子として表されます。</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Var</span></code>：変数は <code class="docutils literal notranslate"><span class="pre">Var</span> <span class="pre">#t</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">term</span> <span class="pre">t</span></code> として表され、<code class="docutils literal notranslate"><span class="pre">n</span></code> は <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t</span></code> 型の項です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TT</span></code> と <code class="docutils literal notranslate"><span class="pre">FF</span></code>：ブール定数を表すコンストラクタで、いずれも <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">Bool</span></code> 型（添字が <code class="docutils literal notranslate"><span class="pre">Bool</span></code>）です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code>：STLC の整数は、タグ付きの F★ 整数として表現されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">App</span></code>：<code class="docutils literal notranslate"><span class="pre">e1</span></code> を <code class="docutils literal notranslate"><span class="pre">e2</span></code> に適用するには、<code class="docutils literal notranslate"><span class="pre">e1</span></code> が関数型 <code class="docutils literal notranslate"><span class="pre">TArrow</span> <span class="pre">t1</span> <span class="pre">t2</span></code> を持ち、<code class="docutils literal notranslate"><span class="pre">e2</span></code> が型 <code class="docutils literal notranslate"><span class="pre">t1</span></code> を持ち、結果 <code class="docutils literal notranslate"><span class="pre">App</span> <span class="pre">e1</span> <span class="pre">e2</span></code> が型 <code class="docutils literal notranslate"><span class="pre">t2</span></code> を持つことを示す必要があります。<code class="docutils literal notranslate"><span class="pre">App</span></code> の添字構造がこの規則を正確に捉えています。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lam</span></code>：そして何より重要なのは、STLC のラムダ項を F★ の関数で表すことです。<code class="docutils literal notranslate"><span class="pre">f</span></code> が <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span></code> 型の引数を受け取り <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">t2</span></code> を返す F★ 関数であるとき、<code class="docutils literal notranslate"><span class="pre">Lam</span> <span class="pre">f</span></code> は型 <code class="docutils literal notranslate"><span class="pre">Arrow</span> <span class="pre">t1</span> <span class="pre">t2</span></code> を持ちます。<code class="docutils literal notranslate"><span class="pre">Lam</span></code> は関数型フィールドを含みますが、その型 <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">term</span> <span class="pre">t2</span></code> は厳密に正であり、<a class="reference internal" href="part2_inductive_type_families.html#part2-strict-positivity"><span class="std std-ref">以前に示した</span></a> <code class="docutils literal notranslate"><span class="pre">dyn</span></code> 型とは異なります。</p></li>
</ul>
</div></blockquote>
</section>
<section id="denotation-of-terms">
<h2>項の意味付け<a class="headerlink" href="#denotation-of-terms" title="Link to this heading"></a></h2>
<p>最後にステップ 3 として、<code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">t</span></code> を型 <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t</span></code> の F★ の項に解釈します。関数と変数の扱いが最も厄介ですが、ここは既に表現側で F★ の適切な項として表されているため、そのまま利用できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> denote_term (#t:typ) (e:term t)
  : <span class="k">Tot</span> (denote_typ t)
        (<span class="k">decreases</span> e)
  = <span class="k">match</span> e <span class="k">with</span>
    | Var x -&gt; x
    | TT -&gt; <span class="k">true</span>
    | FF -&gt; <span class="k">false</span>
    | I i -&gt; i
    | App f a -&gt; (denote_term f) (denote_term a)
    | Lam f -&gt; <span class="k">fun</span> x -&gt; denote_term (f x)
</pre></div>
</div>
<p>各ケースを見ていきます。</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Var</span></code> の場合は容易です。変数 <code class="docutils literal notranslate"><span class="pre">x</span></code> はすでに適切な F★ 型の要素として解釈されています。</p></li>
<li><p>定数 <code class="docutils literal notranslate"><span class="pre">TT</span></code>、<code class="docutils literal notranslate"><span class="pre">FF</span></code>、<code class="docutils literal notranslate"><span class="pre">I</span></code> も同様に簡単で、対応するブール値や整数の定数として解釈します。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">App</span> <span class="pre">#t1</span> <span class="pre">#t2</span> <span class="pre">f</span> <span class="pre">a</span></code> の場合、<code class="docutils literal notranslate"><span class="pre">f</span></code> と <code class="docutils literal notranslate"><span class="pre">a</span></code> を再帰的に解釈します。添字から、<code class="docutils literal notranslate"><span class="pre">f</span></code> は <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">denote_typ</span> <span class="pre">t2</span></code> 型の F★ 関数に、<code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">a</span></code> は <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span></code> 型になると分かります。したがって、<code class="docutils literal notranslate"><span class="pre">f</span></code> の解釈を <code class="docutils literal notranslate"><span class="pre">a</span></code> の解釈に適用すれば、<code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t2</span></code> 型の項が得られます。言い換えると、STLC の関数適用は、意味的には F★ の関数適用で表されます。</p></li>
<li><p>最後に <code class="docutils literal notranslate"><span class="pre">Lam</span> <span class="pre">#t1</span> <span class="pre">#t2</span> <span class="pre">f</span></code> の場合、必要なのは <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span> <span class="pre">-&gt;</span> <span class="pre">denote_typ</span> <span class="pre">t2</span></code> 型の項です。そこで、引数 <code class="docutils literal notranslate"><span class="pre">x</span></code> を <code class="docutils literal notranslate"><span class="pre">denote_typ</span> <span class="pre">t1</span></code> 型とする F★ のラムダを作り、本体で <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> を適用して、得られた <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> に対して再帰的に <code class="docutils literal notranslate"><span class="pre">denote_term</span></code> を呼びます。</p></li>
</ul>
</div></blockquote>
<p>少し魔法のように感じたなら、その通りです！STLC の構文と型付け規則、意味論でもあるインタプリタを定義し、約 30 行のコードと証明で健全性まで示せました。適切な表現を選ぶことで、全てが滑らかに導かれます。</p>
<section id="termination">
<h3>停止性<a class="headerlink" href="#termination" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">e</span></code> の停止を F★ がどう受け入れるのか疑問に思うかもしれません。検討すべき再帰呼び出しは 3 つあります。</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">App</span></code> の 2 回の呼び出しは簡単で、いずれも <code class="docutils literal notranslate"><span class="pre">App</span> <span class="pre">f</span> <span class="pre">a</span></code> の厳密な部分項に対する再帰です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Lam</span> <span class="pre">f</span></code> の場合、再帰呼び出しは <code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">(f</span> <span class="pre">x)</span></code> が 1 回であり、<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> は <code class="docutils literal notranslate"><span class="pre">Lam</span> <span class="pre">f</span></code> より厳密に小さいと F★ は判断します。これは帰納的型における部分項順序（F★ の <code class="docutils literal notranslate"><span class="pre">precedes</span></code> 関係の一部）:ref:<cite>（前出 &lt;Part1_precedes_relation&gt;）</cite> の事例です。</p></li>
</ul>
</div></blockquote>
<p>直観として、<code class="docutils literal notranslate"><span class="pre">term</span></code> 型は「深さは有限だが幅は無限になり得る木」と考えると分かりやすいでしょう。</p>
<blockquote>
<div><ul class="simple">
<li><p>木の葉は <code class="docutils literal notranslate"><span class="pre">Var</span></code>、<code class="docutils literal notranslate"><span class="pre">TT</span></code>、<code class="docutils literal notranslate"><span class="pre">FF</span></code> の各場合です。</p></li>
<li><p>内部ノード <code class="docutils literal notranslate"><span class="pre">App</span> <span class="pre">e0</span> <span class="pre">e1</span></code> は、<code class="docutils literal notranslate"><span class="pre">e0</span></code> と <code class="docutils literal notranslate"><span class="pre">e1</span></code> という 2 つの部分木を組み合わせます。</p></li>
<li><p>内部ノード <code class="docutils literal notranslate"><span class="pre">Lam</span> <span class="pre">#t1</span> <span class="pre">#t2</span> <span class="pre">f</span></code> は可変個の部分木を持ち、その数は引数 <code class="docutils literal notranslate"><span class="pre">t1</span></code> に依存します。例えば：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">Unit</span></code> なら <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">unit</span> <span class="pre">-&gt;</span> <span class="pre">term</span> <span class="pre">v</span> <span class="pre">t</span></code> で、子は 1 つ（<code class="docutils literal notranslate"><span class="pre">f()</span></code>）だけです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">Bool</span></code> なら <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">term</span> <span class="pre">v</span> <span class="pre">t</span></code> で、子は <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">true</span></code> と <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">false</span></code> の 2 つです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">Int</span></code> なら <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">term</span> <span class="pre">v</span> <span class="pre">t</span></code> で、<code class="docutils literal notranslate"><span class="pre">...,</span> <span class="pre">f</span> <span class="pre">(-1),</span> <span class="pre">f</span> <span class="pre">0,</span> <span class="pre">f</span> <span class="pre">1,</span> <span class="pre">...</span></code> のように無限個の子を持ち得ます。</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>この直観に基づけば、各再帰で木の深さは減るため、任意の子に対して <code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">e</span></code> を呼んでも安全で、したがって <code class="docutils literal notranslate"><span class="pre">denote_term</span> <span class="pre">(f</span> <span class="pre">x)</span></code> は停止します。</p>
<p>再帰関数の停止性についての形式的な議論は、<a class="reference internal" href="part2_well_founded.html#part2-well-founded-recursion"><span class="std std-ref">良基底再帰</span></a> の章で改めて扱います。</p>
</section>
</section>
<section id="exercises">
<h2>演習<a class="headerlink" href="#exercises" title="Link to this heading"></a></h2>
<p>STLC に意味論を与えるのは氷山の一角にすぎません。HOAS でできることは他にも多く、Chlipala の論文には Coq による多くの例とサンプルコードが掲載されています。</p>
<p>以下の定義を基に、さらに発展的な演習として、STLC の CPS 変換を行うコンパイラの正当性証明を含め、Chlipala の論文にある他の例を再現してみてください。</p>
<p><a class="reference external" href="../code/Part2.PHOAS.fst">演習ファイル</a></p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="c">(* This example is transcribed from Adam Chlipala&#39;s</span>
<span class="c">   Parametric Higher-order Abstract Syntax (ICFP 2008) paper.</span>

<span class="c">   http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08.pdf</span>
<span class="c">*)</span>
<span class="k">module</span> Part2.PHOAS

<span class="k">type</span> typ =
  | Bool
  | Arrow : typ -&gt; typ -&gt; typ

<span class="k">noeq</span>
<span class="k">type</span> term0 (v: typ -&gt; Type) : typ -&gt; Type =
  | Var : #t:typ -&gt; v t -&gt; term0 v t
  | TT  : term0 v Bool
  | FF  : term0 v Bool
  | App : #t1:typ -&gt; #t2:typ -&gt;
          term0 v (Arrow t1 t2) -&gt;
          term0 v t1 -&gt;
          term0 v t2
  | Lam : #t1:typ -&gt; #t2:typ -&gt;
          (v t1 -&gt; term0 v t2) -&gt;
          term0 v (Arrow t1 t2)

<span class="k">let</span> term (t:typ) = v:(typ -&gt; Type) -&gt; term0 v t

<span class="k">let</span> <span class="k">rec</span> denote_typ (t:typ)
  : Type
  = <span class="k">match</span> t <span class="k">with</span>
    | Bool -&gt; bool
    | Arrow t1 t2 -&gt; (denote_typ t1 -&gt; denote_typ t2)

<span class="k">let</span> <span class="k">rec</span> denote_term0 (#t:typ) (e:term0 denote_typ t)
  : <span class="k">Tot</span> (denote_typ t)
        (<span class="k">decreases</span> e)
  = <span class="k">match</span> e <span class="k">with</span>
    | Var x -&gt; x
    | TT -&gt; <span class="k">true</span>
    | FF -&gt; <span class="k">false</span>
    | App f a -&gt; (denote_term0 f) (denote_term0 a)
    | Lam f -&gt; <span class="k">fun</span> x -&gt; denote_term0 (f x)

<span class="k">let</span> denote_term (t:typ) (e:term t)
  : denote_typ t
  = denote_term0 (e <span class="k">_</span>)
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="part2_stlc.html" class="btn btn-neutral float-left" title="単純型付きラムダ計算（STLC）" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="part2_well_founded.html" class="btn btn-neutral float-right" title="良基底関係と停止性" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>