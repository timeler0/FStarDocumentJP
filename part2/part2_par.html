

<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>計算効果の最初のモデル &mdash; Proof-Oriented Programming in F*  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=24463673" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=c033477b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=4755f45a"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="ユニバース（Universes）" href="part2_universes.html" />
    <link rel="prev" title="良基底関係と停止性" href="part2_well_founded.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Proof-Oriented Programming in F*
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../structure.html">本書の構成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/part1.html">全域関数によるプログラミングと証明</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="part2.html">帰納的型によるデータ・証明・計算の表現</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="part2_inductive_type_families.html">帰納的型の定義</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_vectors.html">長さインデックス付きリスト</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_merkle.html">Merkle 木</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_equality.html">等式型</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_logical_connectives.html">構成的連言と古典的連言（論理結合子）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_stlc.html">単純型付きラムダ計算（STLC）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_phoas.html">高階抽象構文（HOAS）</a></li>
<li class="toctree-l2"><a class="reference internal" href="part2_well_founded.html">良基底関係と停止性</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">計算効果の最初のモデル</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-first-taste-the-state-monad">導入：ステートモナド</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#some-stateful-programs">いくつかの状態付きプログラム</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#monadic-let-bindings">モナディック let 束縛</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#st-is-a-monad"><code class="docutils literal notranslate"><span class="pre">st</span></code> はモナドである</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exercise">練習問題</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">練習問題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#computation-trees-or-monads-generically">計算木：モナドを一般的に扱う</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">練習問題</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">練習問題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#manipulating-computation-trees-nondeterminism-and-concurrency">計算木の操作：非決定性と並行性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">練習問題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#looking-ahead">今後に向けて</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="part2_universes.html">ユニバース（Universes）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part3/part3.html">インターフェースと型クラスによるモジュール性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part4/part4.html">計算効果</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part5/part5.html">Meta-F* によるタクティクスとメタプログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pulse/pulse.html">Pulse: 並行分離論理における証明指向プログラミング</a></li>
<li class="toctree-l1"><a class="reference internal" href="../under_the_hood/under_the_hood.html">内部の仕組み</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="part2.html">帰納的型によるデータ・証明・計算の表現</a></li>
      <li class="breadcrumb-item active">計算効果の最初のモデル</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
             
  <section id="a-first-model-of-computational-effects">
<span id="part2-par"></span><h1>計算効果の最初のモデル<a class="headerlink" href="#a-first-model-of-computational-effects" title="Link to this heading"></a></h1>
<p>本節の締めくくりとして、帰納的型を用いてデータだけでなく <em>計算*（可変状態や共有メモリ型の並行性のような副作用を伴う計算を含む）もモデル化できることを示します。あわせて、次節の内容――効果を持つプログラムのモデル化と性質の証明、および F</em> のユーザ拡張可能なインデックス付き効果の体系――のさわりも紹介します。</p>
<p>本章の一部の内容については、Guido Martinez と Danel Ahman に感謝します。</p>
<section id="a-first-taste-the-state-monad">
<h2>導入：ステートモナド<a class="headerlink" href="#a-first-taste-the-state-monad" title="Link to this heading"></a></h2>
<p>これまでに書いてきたプログラムは純粋関数型でした。しかし、純粋関数型言語の内部でも可変状態を操作するプログラムをモデル化できます。その一般的で強力な方法が <em>モナド</em> です。モナドの考え方は、<a class="reference external" href="https://ieeexplore.ieee.org/document/39155">Eugenio Moggi</a> による意味論の基盤の上に、<a class="reference external" href="https://dl.acm.org/doi/10.1145/143165.143169">Philip Wadler</a> が 1980 年代末から 90 年代初頭にかけて関数型プログラマに紹介したものです。もし以前にモナドで戸惑ったことがあっても、ここではゼロから始めます。今回はすべてが腑に落ちるはずです！</p>
<p>1 個の可変状態――プログラムが読み書きできる単一の整数――を操作し、結果として型 <code class="docutils literal notranslate"><span class="pre">a</span></code> の値を返すプログラムをモデル化してみましょう。その 1 つの方法は、このような <em>状態付き計算</em> を型 <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">a</span></code> を持つプログラムとして表すことです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> st a = int -&gt; a &amp; int
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">a</span></code> 計算は、初期状態 <code class="docutils literal notranslate"><span class="pre">s0</span></code> を与えると、計算結果 <code class="docutils literal notranslate"><span class="pre">x:a</span></code> と最終状態 <code class="docutils literal notranslate"><span class="pre">s1</span></code> からなる組 <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">s1)</span></code> を返す関数です。</p>
<p>例えば、状態を読み出してそれをインクリメントし、初期の状態値を返す計算は次のように書けます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read_and_increment_v0
  : st int
  = <span class="k">fun</span> s0 -&gt; s0, s0 + 1
</pre></div>
</div>
<p>これは素直ですが、このスタイルで計算を書くのは面倒で間違いも起こりやすいです。例えば、状態を読み取り 2 回インクリメントしたければ、次のように書きます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> inc_twice_v0
  : st int
  = <span class="k">fun</span> s0 -&gt;
      <span class="k">let</span> x, s1 = read_and_increment_v0 s0 <span class="k">in</span>
      <span class="k">let</span> <span class="k">_</span>, s2 = read_and_increment_v0 s1 <span class="k">in</span>
      x, s2
</pre></div>
</div>
<p>これはかなり不格好です。というのも、<code class="docutils literal notranslate"><span class="pre">read_and_increment_v0</span></code> を呼ぶたびに「最新の状態」を渡すよう細心の注意が必要だからです。例えば、ちょっとしたタイプミスで、2 回目の <code class="docutils literal notranslate"><span class="pre">read_and_increment</span></code> に <code class="docutils literal notranslate"><span class="pre">s0</span></code> を渡してしまい、結局 1 回しかインクリメントされないプログラムになりがちです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> inc_twice_buggy
  : st int
  = <span class="k">fun</span> s0 -&gt;
      <span class="k">let</span> x, s1 = read_and_increment_v0 s0 <span class="k">in</span>
      <span class="k">let</span> <span class="k">_</span>, s2 = read_and_increment_v0 s0 <span class="k">in</span>
      x, s2
</pre></div>
</div>
<p>ステートモナドの要点は、状態操作に関わる配線（plumbing）を抽象化して隠し、面倒やエラーの温床を取り除きつつ状態付きプログラムを構成することにあります。</p>
<p>これを実現するには、状態の読み書きのための関数、状態に触れずに純粋な値を返す関数（状態に対しては no-op の恒等のようなもの）を定義し、さらに 2 つの状態付き計算を順に合成する関数を用意します。</p>
<ul class="simple">
<li><p>以下の <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">:</span> <span class="pre">st</span> <span class="pre">int</span></code> は状態を読み出して返す関数で、状態は変更しません。</p></li>
</ul>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read
  : st int
  = <span class="k">fun</span> s -&gt; s, s
</pre></div>
</div>
<ul class="simple">
<li><p>以下の <code class="docutils literal notranslate"><span class="pre">write</span> <span class="pre">(s1:int)</span> <span class="pre">:</span> <span class="pre">st</span> <span class="pre">unit</span></code> は状態を <code class="docutils literal notranslate"><span class="pre">s1</span></code> に設定し、<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">:</span> <span class="pre">unit</span></code> を返します。</p></li>
</ul>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> write (s1:int)
  : st unit
  = <span class="k">fun</span> <span class="k">_</span> -&gt; (), s1
</pre></div>
</div>
<ul class="simple">
<li><p>最も興味深いのは <code class="docutils literal notranslate"><span class="pre">bind</span></code> でしょう。<code class="docutils literal notranslate"><span class="pre">f:</span> <span class="pre">st</span> <span class="pre">a</span></code> という状態付き計算と、その結果に依存して状態を読み書きしつつ <code class="docutils literal notranslate"><span class="pre">b</span></code> を返し得る <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">st</span> <span class="pre">b</span></code> があるとき、<code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">g</span></code> は <code class="docutils literal notranslate"><span class="pre">f</span></code> と <code class="docutils literal notranslate"><span class="pre">g</span></code> を順に合成します。初期状態 <code class="docutils literal notranslate"><span class="pre">s0</span></code> を <code class="docutils literal notranslate"><span class="pre">f</span></code> に渡し、得られた結果 <code class="docutils literal notranslate"><span class="pre">x</span></code> と次の状態 <code class="docutils literal notranslate"><span class="pre">s1</span></code> を <code class="docutils literal notranslate"><span class="pre">g</span></code> に渡します。</p></li>
</ul>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> bind #a #b
         (f: st a)
         (g: a -&gt; st b)
  : st b
  = <span class="k">fun</span> s0 -&gt;
      <span class="k">let</span> x, s1 = f s0 <span class="k">in</span>
      g x s1
</pre></div>
</div>
<ul class="simple">
<li><p>最後に <code class="docutils literal notranslate"><span class="pre">return</span></code> は、純粋な値 <code class="docutils literal notranslate"><span class="pre">x:a</span></code> を、状態に触れずに <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">a</span></code> に持ち上げます。</p></li>
</ul>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> return #a (x:a)
  : st a
  = <span class="k">fun</span> s -&gt; x, s
</pre></div>
</div>
<section id="some-stateful-programs">
<h3>いくつかの状態付きプログラム<a class="headerlink" href="#some-stateful-programs" title="Link to this heading"></a></h3>
<p>これらのコンビネータを使えば、状態を保持する整数変数を直接いじることなく、より簡潔に状態付きプログラムを書けます。</p>
<p><code class="docutils literal notranslate"><span class="pre">read_and_increment</span></code> の別案は次のとおりです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read_and_increment_v1 : st int = 
  bind read (<span class="k">fun</span> x -&gt; 
  bind (write (x + 1)) (<span class="k">fun</span> <span class="k">_</span> -&gt; 
  return x))
</pre></div>
</div>
<p>これでは <code class="docutils literal notranslate"><span class="pre">read_and_increment_v0</span></code> より悪く見える、と思ったかもしれません。曖昧に見えるのは <code class="docutils literal notranslate"><span class="pre">bind</span></code> 呼び出しの構文が回りくどいからに過ぎません。多くの言語（代表例は Haskell）は、<code class="docutils literal notranslate"><span class="pre">bind</span></code> や <code class="docutils literal notranslate"><span class="pre">return</span></code> のような API を使う計算の記述を簡略化する専用構文を提供します。F* も同様の糖衣構文を提供します。</p>
</section>
</section>
<section id="monadic-let-bindings">
<h2>モナディック let 束縛<a class="headerlink" href="#monadic-let-bindings" title="Link to this heading"></a></h2>
<p>以下では、特別な名前 <code class="docutils literal notranslate"><span class="pre">let!</span></code> を持つ関数を定義します。<code class="docutils literal notranslate"><span class="pre">let</span></code> に続けて <code class="docutils literal notranslate"><span class="pre">!</span></code> や <code class="docutils literal notranslate"><span class="pre">?</span></code>、<code class="docutils literal notranslate"><span class="pre">&#64;</span></code>、<code class="docutils literal notranslate"><span class="pre">$</span></code>、<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>、<code class="docutils literal notranslate"><span class="pre">&gt;</span></code> などの演算子文字列を付けた形の名前は、モナディック let 束縛演算子です。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> (<span class="k">let</span>!) = bind
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">let!</span></code> がスコープ内にあると、次の糖衣構文が使えます。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">e)</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">let!</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">in</span> <span class="pre">e</span></code> と書けます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">(fun</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">e)</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">;!</span> <span class="pre">e</span></code> と書けます（セミコロンに、モナディック let 束縛演算子で使った演算子列を続けます）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">match</span> <span class="pre">x</span> <span class="pre">with</span> <span class="pre">...)</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">match!</span> <span class="pre">f</span> <span class="pre">with</span> <span class="pre">...</span></code> と書けます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">...)</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">if!</span> <span class="pre">f</span> <span class="pre">then</span> <span class="pre">...</span></code> と書けます。</p></li>
</ul>
<p>糖衣構文の詳細と例は <a class="reference external" href="https://github.com/FStarLang/FStar/blob/master/examples/misc/MonadicLetBindings.fst">MonadicLetBindings.fst</a> を参照してください。</p>
<p>この糖衣構文を用いると、<code class="docutils literal notranslate"><span class="pre">read_and_increment</span></code> の最終版は次のようになります。命令的に見える状態更新のおかげで、プログラムの意図が明確になったはずです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read_and_increment : st int =
  <span class="k">let</span>! x = read <span class="k">in</span>
  write (x + 1) ;!
  return x
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code> と <code class="docutils literal notranslate"><span class="pre">bind</span></code> でプログラムを構成しておけば、状態の受け渡しという配線について心配することなく、小さな <code class="docutils literal notranslate"><span class="pre">st</span></code> 計算から大きなものを組み立てられます――配線はコンビネータが一度きりで引き受けてくれます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> inc_twice : st int = 
  <span class="k">let</span>! x = read_and_increment <span class="k">in</span>
  read_and_increment ;!
  return x
</pre></div>
</div>
<section id="st-is-a-monad">
<span id="part2-monad-intro"></span><h3><code class="docutils literal notranslate"><span class="pre">st</span></code> はモナドである<a class="headerlink" href="#st-is-a-monad" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">st</span></code> のように構成された API は、<em>モナド</em> と呼ばれる一般的パターン（代数的構造）のインスタンスになっています。具体的に、モナドは次から成ります。</p>
<blockquote>
<div><ul class="simple">
<li><p>型演算子 <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(#a:Type)</span> <span class="pre">(x:a)</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">a</span></code></p></li>
<li><p>関数 <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">(#a</span> <span class="pre">#b:Type)</span> <span class="pre">(f:m</span> <span class="pre">a)</span> <span class="pre">(g:</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b)</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">b</span></code></p></li>
</ul>
</div></blockquote>
<p>これらは次の法則を満たします。ここで <cite>~</cite> は <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">a</span></code> 上の適切な同値関係です。</p>
<blockquote>
<div><ul class="simple">
<li><p>左単位律：<code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">(return</span> <span class="pre">x)</span> <span class="pre">f</span> <span class="pre">~</span> <span class="pre">f</span></code></p></li>
<li><p>右単位律：<code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f</span> <span class="pre">return</span> <span class="pre">~</span> <span class="pre">f</span></code></p></li>
<li><p>結合律：<code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">f1</span> <span class="pre">(fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">bind</span> <span class="pre">(f2</span> <span class="pre">x)</span> <span class="pre">f3)</span> <span class="pre">~</span> <span class="pre">bind</span> <span class="pre">(bind</span> <span class="pre">f1</span> <span class="pre">f2)</span> <span class="pre">f3</span></code></p></li>
</ul>
</div></blockquote>
<p>F* では、等しい引数に対して等しい結果を返す関数を同一視するような同値関係を選べば、<code class="docutils literal notranslate"><span class="pre">st</span></code>、<code class="docutils literal notranslate"><span class="pre">return</span></code>、<code class="docutils literal notranslate"><span class="pre">bind</span></code> がこれらの法則を満たすことを容易に証明できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> feq #a #b (f g : a -&gt; b) = <span class="k">forall</span> x. f x == g x
<span class="k">let</span> left_identity #a #b (x:a) (g: a -&gt; st b)
  : <span class="k">Lemma</span> ((<span class="k">let</span>! v = return x <span class="k">in</span> g v) `feq` g x)
  = ()
<span class="k">let</span> right_identity #a (f:st a)
  : <span class="k">Lemma</span> ((<span class="k">let</span>! x = f <span class="k">in</span> return x) `feq` f)
  = ()
<span class="k">let</span> associativity #a #b #c (f1:st a) (f2:a -&gt; st b) (f3:b -&gt; st c)
  : <span class="k">Lemma</span> ((<span class="k">let</span>! x = f1 <span class="k">in</span> <span class="k">let</span>! y = f2 x <span class="k">in</span> f3 y) `feq`
           (<span class="k">let</span>! y = (<span class="k">let</span>! x = f1 <span class="k">in</span> f2 x) <span class="k">in</span> f3 y))
  = ()
</pre></div>
</div>
<p>これらの法則は実用上も有用で、コンビネータの実装に潜むバグを炙り出せます。例えば、<code class="docutils literal notranslate"><span class="pre">inc_twice_buggy</span></code> と同様に、<code class="docutils literal notranslate"><span class="pre">g</span></code> の呼び出しで誤って古い状態 <code class="docutils literal notranslate"><span class="pre">s0</span></code> を再利用してしまう <code class="docutils literal notranslate"><span class="pre">bind_buggy</span></code> を書いたとします――この場合、以下の <code class="docutils literal notranslate"><span class="pre">right_identity</span></code> は証明できません。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> bind_buggy #a #b
               (f: st a)
               (g: a -&gt; st b)
  : st b
  = <span class="k">fun</span> s0 -&gt;
      <span class="k">let</span> x, s1 = f s0 <span class="k">in</span>
      g x s0
[@@expect_failure]
<span class="k">let</span> right_identity_fail #a (f:st a)
  : <span class="k">Lemma</span> (bind_buggy f return `feq` f)
  = ()
</pre></div>
</div>
<p>また、状態付きの基本動作である <code class="docutils literal notranslate"><span class="pre">read</span></code> と <code class="docutils literal notranslate"><span class="pre">write</span></code> が逐次合成でどう相互作用するかについての法則も証明できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> redundant_read_elim ()
  : <span class="k">Lemma</span> ((read;! read) `feq` read)
  = ()

<span class="k">let</span> redundant_write_elim (x y:int)
  : <span class="k">Lemma</span> ((write x ;! write y) `feq` write y)
  = ()

<span class="k">let</span> read_write_noop ()
  : <span class="k">Lemma</span> ((<span class="k">let</span>! x = read <span class="k">in</span> write x) `feq` return ())
  = ()
</pre></div>
</div>
<p>以上で、最初のモナドであるステートモナドの概観を終えます。</p>
</section>
<section id="exercise">
<h3>練習問題<a class="headerlink" href="#exercise" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">st</span></code> 型を総称化して、状態が固定の整数ではなく任意の型を扱えるようにしなさい。すなわち、状態の型を <code class="docutils literal notranslate"><span class="pre">s</span></code> とする <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">(s:Type)</span> <span class="pre">(a:Type)</span> <span class="pre">:</span> <span class="pre">Type</span></code> を定義しなさい。</p>
<p>上で見た一連の開発を <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">s</span></code> 版に合わせて修正し、各種の法則の証明も含めて完成させなさい。</p>
<p><a class="reference external" href="../code/exercises/Part2.ST.fst">演習ファイル</a></p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> Part2.ST

<span class="k">let</span> st s a = s -&gt; a &amp; s

<span class="k">let</span> read #s
  : st s s
  = <span class="k">fun</span> s -&gt; s, s

<span class="k">let</span> write #s (s1:s)
  : st s unit
  = <span class="k">fun</span> <span class="k">_</span> -&gt; (), s1

<span class="k">let</span> bind #s #a #b
         (f: st s a)
         (g: a -&gt; st s b)
  : st s b
  = <span class="k">fun</span> s0 -&gt;
      <span class="k">let</span> x, s1 = f s0 <span class="k">in</span>
      g x s1

<span class="k">let</span> return #s #a (x:a)
  : st s a
  = <span class="k">fun</span> s -&gt; x, s

<span class="k">let</span> read_and_increment : st int int =
  x &lt;-- read;
  write (x + 1);;
  return x

<span class="k">let</span> inc_twice : st int int = 
  x &lt;-- read_and_increment;
  read_and_increment;;
  return x

<span class="k">let</span> feq #a #b (f g : a -&gt; b) = <span class="k">forall</span> x. f x == g x
<span class="k">let</span> left_identity #s #a #b (x:a) (g: a -&gt; st s b)
  : <span class="k">Lemma</span> ((v &lt;-- return x; g v) `feq` g x)
  = ()
<span class="k">let</span> right_identity #s #a (f:st s a)
  : <span class="k">Lemma</span> ((x &lt;-- f; return x) `feq` f)
  = ()
<span class="k">let</span> associativity #s #a #b #c (f1:st s a) (f2:a -&gt; st s b) (f3:b -&gt; st s c)
  : <span class="k">Lemma</span> ((x &lt;-- f1; y &lt;-- f2 x; f3 y) `feq`
           (y &lt;-- (x &lt;-- f1; f2 x); f3 y))
  = ()

<span class="k">let</span> redundant_read_elim ()
  : <span class="k">Lemma</span> ((read;; read) `feq` read)
  = ()

<span class="k">let</span> redundant_write_elim (x y:int)
  : <span class="k">Lemma</span> ((write x ;; write y) `feq` write y)
  = ()

<span class="k">let</span> read_write_noop ()
  : <span class="k">Lemma</span> ((x &lt;-- read;  write x) `feq` return ())
  = ()
</pre></div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="id1">
<h3>練習問題<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>モナドは可変状態に限らず、多様な計算効果をモデル化できます。よくある別の例は、実行時エラーを起こし得る計算のモデル化です。そのやり方を理解するための演習を示します。</p>
<p><code class="docutils literal notranslate"><span class="pre">option</span></code> 型がモナドになることを示しなさい。すなわち、<code class="docutils literal notranslate"><span class="pre">bind</span></code> と <code class="docutils literal notranslate"><span class="pre">return</span></code> を定義し、モナド則を証明しなさい。</p>
<p><a class="reference external" href="../code/exercises/Part2.Option.fst">演習ファイル</a></p>
</section>
</section>
<hr class="docutils" />
<section id="computation-trees-or-monads-generically">
<h2>計算木：モナドを一般的に扱う<a class="headerlink" href="#computation-trees-or-monads-generically" title="Link to this heading"></a></h2>
<p>計算効果をモデル化するモナドを定義する際には、まず関係する効果的な <a href="#id1"><span class="problematic" id="id2">*</span></a>動作*（例：状態の読み書き、エラー送出）を考え、それらを <code class="docutils literal notranslate"><span class="pre">return</span></code> と <code class="docutils literal notranslate"><span class="pre">bind</span></code> を備えたモナドのインターフェースに包み、最後にその実装がモナド則を満たすことを確認します。</p>
<p>しかし、これは定型作業が多く、関数（<code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">s</span></code> のような）として表す代わりに、各ノードで効果的な動作を明示した <em>計算木</em> を表す帰納的型として一度定義しておけば事足ります。この表現（<em>自由モナド</em> と呼ばれることもあります）がモナドであることを証明したうえで、任意のプログラムで使いたい動作の種類に合わせて繰り返し具体化できます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>本節は <em>代数的効果</em> と呼ばれる豊かな研究分野の入門にすぎません。ここでは本格的な代数的効果の展開までは扱いません（後の章で取り上げます）が、参考資料を挙げておきます。</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/FStarLang/FStar/blob/master/examples/layeredeffects/Alg.fst">Alg.fst</a>：代数的効果に関する F* の開発例（詳細は後章で扱います）。</p></li>
<li><p><a class="reference external" href="https://koka-lang.github.io/koka/doc/index.html">Koka</a>：代数的効果を中核に据えた言語</p></li>
<li><p><a class="reference external" href="https://github.com/yallop/effects-bibliography">effects</a> に関する文献リスト</p></li>
</ul>
</div></blockquote>
</div>
<p>まず、動作の言語のシグネチャを記述する型から、計算木の開発を始めます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">noeq</span>
<span class="k">type</span> action_class = {
  t : Type;
  input_of : t -&gt; Type;
  output_of : t -&gt; Type;
}
</pre></div>
</div>
<p>この種のシグネチャは <em>型クラス</em> と呼ばれることがあります。すなわち、型 <code class="docutils literal notranslate"><span class="pre">act:Type</span></code> と、それがサポートする操作の集合です。ここでは、操作が各アクションの入力と出力の型を教えてくれます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>F* は型クラスと、そのインスタンスの推論もサポートします。これについては後の章で説明します。当面は、F* の型クラスの詳細を <a class="reference external" href="https://github.com/FStarLang/FStar/wiki/Typeclasses-(via-meta-arguments">Wiki</a> や これらの <a class="reference external" href="https://github.com/FStarLang/FStar/tree/master/examples/typeclasses">例</a> で学べます。</p>
</div>
<p>For example, if we were interested in just the read/write actions on a
mutable integer state (as in our <code class="docutils literal notranslate"><span class="pre">st</span> <span class="pre">a</span></code> example), we could build an
instance of the <code class="docutils literal notranslate"><span class="pre">action_class</span></code>, as shown below.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> rw =
  | Read
  | Write

<span class="k">let</span> input_of : rw -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | Read -&gt; unit
    | Write -&gt; int

<span class="k">let</span> output_of : rw -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | Read -&gt; int
    | Write -&gt; unit

<span class="k">let</span> rw_action_class = { t = rw; input_of ; output_of }
</pre></div>
</div>
<p>一方で、<code class="docutils literal notranslate"><span class="pre">tree</span> <span class="pre">acts</span> <span class="pre">a</span></code> という型――効果的な動作が <code class="docutils literal notranslate"><span class="pre">acts</span></code> に属する計算木の型――を、動作そのものに関して完全に総称的に定義できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">noeq</span>
<span class="k">type</span> tree (acts:action_class) (a:Type) =
  | Return : x:a -&gt; tree acts a
  | DoThen : act:acts.t -&gt;
             input:acts.input_of act -&gt;
             continue: (acts.output_of act -&gt; tree acts a) -&gt;
             tree acts a
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tree</span> <span class="pre">act</span> <span class="pre">a</span></code> には 2 つの場合があります。</p>
<blockquote>
<div><ul class="simple">
<li><p>葉ノード <code class="docutils literal notranslate"><span class="pre">Return</span> <span class="pre">x</span></code>：値 <code class="docutils literal notranslate"><span class="pre">x</span></code> を即座に返す計算を表します。</p></li>
<li><p>あるいは、<code class="docutils literal notranslate"><span class="pre">DoThen</span> <span class="pre">act</span> <span class="pre">input</span> <span class="pre">k</span></code>：まずアクション <code class="docutils literal notranslate"><span class="pre">act</span></code> を入力付きで実行し、その返り得る各出力に対して次に進む &quot;継続&quot; を <code class="docutils literal notranslate"><span class="pre">k</span></code> が与える、という計算です。継続は各出力に対する <code class="docutils literal notranslate"><span class="pre">tree</span> <span class="pre">act</span> <span class="pre">a</span></code> で表されます。つまり <code class="docutils literal notranslate"><span class="pre">DoThen</span></code> は 1 つのアクションと、（場合によっては無限個の）部分木を持つノードです。</p></li>
</ul>
</div></blockquote>
<p>この表現に基づいて <code class="docutils literal notranslate"><span class="pre">return</span></code> と <code class="docutils literal notranslate"><span class="pre">bind</span></code> を定義し、モナド則を一度きりで証明できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> return #a #acts (x:a)
  : tree acts a
  = Return x

<span class="k">let</span> <span class="k">rec</span> bind #acts #a #b (f: tree acts a) (g: a -&gt; tree acts b)
  : tree acts b
  = <span class="k">match</span> f <span class="k">with</span>
    | Return x -&gt; g x
    | DoThen act i k -&gt;
      DoThen act i (<span class="k">fun</span> x -&gt; bind (k x) g)
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">return</span></code> は簡単で、木の型に <code class="docutils literal notranslate"><span class="pre">Return</span></code> という葉ノードが既にあるからです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bind</span></code> は少し面白く、木に対する構造再帰になります。前章の良基底再帰と同様に、<code class="docutils literal notranslate"><span class="pre">k</span></code> が返すすべての木が元の木 <code class="docutils literal notranslate"><span class="pre">f</span></code> より厳密に小さいという性質に依拠します。</p></li>
</ul>
<p>モナド則を証明するには、まず木上の同値関係を定義する必要があります。各継続は木を返す関数なので、単なる <code class="docutils literal notranslate"><span class="pre">==</span></code> では不十分です。そこで <code class="docutils literal notranslate"><span class="pre">equiv</span></code> を定義し、両者がともに <code class="docutils literal notranslate"><span class="pre">Return</span></code> であるか、同じアクションで始まり、継続が点ごとに同値である場合に木どうしを関係付けます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> equiv #acts #a (x y: tree acts a) =
  <span class="k">match</span> x, y <span class="k">with</span> 
  | Return vx, Return vy -&gt; vx == vy
  | DoThen actx ix kx, DoThen acty iy ky -&gt;
    actx == acty /\
    ix == iy /\
    (<span class="k">forall</span> o. equiv (kx o) (ky o))
  | <span class="k">_</span> -&gt; False
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ここでは、点ごとに等しい <span class="math notranslate nohighlight">\(\eta\)</span> 展開関数を同一視する性質である <a class="reference internal" href="part2_equality.html#part2-funext"><span class="std std-ref">関数外延性</span></a> の使用をあえて避けています。この開発で関数外延性を使う方法は上級演習として示します。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">equiv</span></code> が同値関係であること、すなわち反射性・対称性・推移性を示す補題を以下に示します。ここでは、<a class="reference internal" href="part2_logical_connectives.html#part2-connectives"><span class="std std-ref">前章</span></a> で導入した論理結合子の糖衣構文も用います。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> equiv_refl #acts #a (x:tree acts a) 
  : <span class="k">Lemma</span> (equiv x x)
  = <span class="k">match</span> x <span class="k">with</span>
    | Return v -&gt; ()
    | DoThen act i k -&gt; 
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (k o) (k o)
      <span class="k">with</span> (equiv_refl (k o))

<span class="k">let</span> <span class="k">rec</span> equiv_sym #acts #a (x y:tree acts a) 
  : <span class="k">Lemma</span> 
    (<span class="k">requires</span> equiv x y)
    (<span class="k">ensures</span> equiv y x)
  = <span class="k">match</span> x, y <span class="k">with</span>
    | Return <span class="k">_</span>, Return <span class="k">_</span> -&gt; ()
    | DoThen act i kx, DoThen <span class="k">_</span> <span class="k">_</span> ky -&gt; 
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (ky o) (kx o)
      <span class="k">with</span> equiv_sym (kx o) (ky o)

<span class="k">let</span> <span class="k">rec</span> equiv_trans #acts #a (x y z: tree acts a)
  : <span class="k">Lemma</span> 
    (<span class="k">requires</span> equiv x y /\ equiv y z)
    (<span class="k">ensures</span> equiv x z)
  = <span class="k">match</span> x, y, z <span class="k">with</span>
    | Return <span class="k">_</span>, <span class="k">_</span>, <span class="k">_</span> -&gt; ()
    | DoThen act i kx, DoThen <span class="k">_</span> <span class="k">_</span> ky, DoThen <span class="k">_</span> <span class="k">_</span> kz -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (kx o) (kz o)
      <span class="k">with</span> equiv_trans (kx o) (ky o) (kz o)
</pre></div>
</div>
<p>これで、<code class="docutils literal notranslate"><span class="pre">tree</span></code> が <code class="docutils literal notranslate"><span class="pre">equiv</span></code> に関してモナド則を満たすことを証明できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> right_identity #acts #a #b (x:a) (g:a -&gt; tree acts b)
  : <span class="k">Lemma</span> (bind (return x) g `equiv` g x)
  = equiv_refl (g x)

<span class="k">let</span> <span class="k">rec</span> left_identity #acts #a (f:tree acts a)
  : <span class="k">Lemma</span> (bind f return `equiv` f)
  = <span class="k">match</span> f <span class="k">with</span>
    | Return <span class="k">_</span> -&gt; ()
    | DoThen act i k -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. bind (k o) return `equiv` (k o)
      <span class="k">with</span> left_identity (k o)

<span class="k">let</span> <span class="k">rec</span> assoc #acts #a #b #c 
              (f1: tree acts a)
              (f2: a -&gt; tree acts b)
              (f3: b -&gt; tree acts c)
  : <span class="k">Lemma</span> (bind f1 (<span class="k">fun</span> x -&gt; bind (f2 x) f3) `equiv`
           bind (bind f1 f2) f3)
  = <span class="k">match</span> f1 <span class="k">with</span>
    | Return v -&gt; 
      right_identity v f2;
      right_identity v (<span class="k">fun</span> x -&gt; bind (f2 x) f3)
    | DoThen act i k -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. bind (k o) (<span class="k">fun</span> x -&gt; bind (f2 x) f3) `equiv`
                     bind (bind (k o) f2) f3
      <span class="k">with</span> assoc (k o) f2 f3
</pre></div>
</div>
<p>特に結合律は直観的です。<code class="docutils literal notranslate"><span class="pre">tree</span> <span class="pre">acts</span> <span class="pre">a</span></code> は、1 つのアクションとその継続という標準の「完全左結合」な形で計算を表します。したがって、<code class="docutils literal notranslate"><span class="pre">bind</span></code> でどう結合しても、基礎となる表現は常に完全左結合です。</p>
<p>計算木を総称的に定義しておけば、任意の動作と組み合わせて使えます。例えば、計算木を使って <code class="docutils literal notranslate"><span class="pre">read_and_increment</span></code> を書き直すと次のようになります。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read : tree rw_action_class int = DoThen Read () Return
<span class="k">let</span> write (x:int) : tree rw_action_class unit = DoThen Write x Return
<span class="k">let</span> read_and_increment 
  : tree rw_action_class int
  = x &lt;-- read ;
    write (x + 1);;
    return x
</pre></div>
</div>
<p>最後に、計算木が与えられたら、それを状態渡しの関数として解釈して「実行」できます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> st a = int -&gt; a &amp; int
<span class="k">let</span> <span class="k">rec</span> interp #a (f: tree rw_action_class a)
  : st a 
  = <span class="k">fun</span> s0 -&gt; 
     <span class="k">match</span> f <span class="k">with</span>
     | Return x -&gt; x, s0
     | DoThen Read i k -&gt; 
       interp (k s0) s0
     | DoThen Write s1 k -&gt; 
       interp (k ()) s1
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ここでの <code class="docutils literal notranslate"><span class="pre">interp</span></code> と、一般的な代数的効果の扱いとの主な違いは、各アクションの解釈を <code class="docutils literal notranslate"><span class="pre">interp</span></code> に「焼き込む」のではなく、例外処理に似た考え方でアクションの意味論を抽象化できる点です。すなわち、異なるハンドラを与えるだけで、文脈側でアクションの意味論をカスタマイズできます。</p>
</div>
<section id="id2">
<h3>練習問題<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">interp</span></code> 関数が、同値な木 <code class="docutils literal notranslate"><span class="pre">f</span></code> と <code class="docutils literal notranslate"><span class="pre">g</span></code> を点ごとに同値な関数へと解釈することを証明しなさい。</p>
<p><a class="reference external" href="../code/exercises/Part2.ComputationTreeEquiv.fst">演習ファイル</a></p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> feq #a #b (f g: a -&gt; b) = <span class="k">forall</span> x. f x == g x
<span class="k">let</span> <span class="k">rec</span> interp_equiv #a (f g:tree rw_action_class a)
  : <span class="k">Lemma</span>
    (<span class="k">requires</span> equiv f g)
    (<span class="k">ensures</span> feq (interp f) (interp g))
  = <span class="k">match</span> f, g <span class="k">with</span>
    | Return <span class="k">_</span>, Return <span class="k">_</span> -&gt; ()
    | DoThen act i kf, DoThen <span class="k">_</span> <span class="k">_</span> kg -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. feq (interp (kf o)) (interp (kg o))
      <span class="k">with</span> interp_equiv (kf o) (kg o)
</pre></div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="id3">
<h3>練習問題<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">interp</span></code> のような関数が同値な木に適用されたとき同値な結果を返すことを毎回証明する代わりに、関数外延性を用いて、同値な木は実際に可証的に等しい、すなわち <code class="docutils literal notranslate"><span class="pre">equiv</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">==&gt;</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> を証明できます。</p>
<p>これは少し技術的です。関数外延性は F* では定理ですが、<span class="math notranslate nohighlight">\(\eta\)</span> 展開された関数に対してのみ成り立つためです。</p>
<p><code class="docutils literal notranslate"><span class="pre">FStar.FunctionalExtensionality.fsti</span></code> を利用して上の定義を調整し、補題 <code class="docutils literal notranslate"><span class="pre">equiv</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">==&gt;</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> を証明できるようにしてみなさい。</p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> Part2.FreeFunExt
<span class="k">open</span> FStar.Classical.Sugar
<span class="k">module</span> F = FStar.FunctionalExtensionality
<span class="k">open</span> FStar.FunctionalExtensionality

<span class="k">noeq</span>
<span class="k">type</span> action_class = {
  t : Type;
  input_of : t -&gt; Type;
  output_of : t -&gt; Type;
}


<span class="k">noeq</span>
<span class="k">type</span> tree (acts:action_class) (a:Type) =
  | Return : x:a -&gt; tree acts a
  | DoThen : act:acts.t -&gt;
             input:acts.input_of act -&gt;
             <span class="c">//We have to restrict continuations to be eta expanded</span>
             <span class="c">//that what `^-&gt;` does. Its defined in FStar.FunctionalExtensionality</span>
             continue:(acts.output_of act ^-&gt; tree acts a) -&gt;
             tree acts a

<span class="k">let</span> return #a #acts (x:a)
  : tree acts a
  = Return x

<span class="k">let</span> <span class="k">rec</span> bind #acts #a #b (f: tree acts a) (g: a -&gt; tree acts b)
  : tree acts b
  = <span class="k">match</span> f <span class="k">with</span>
    | Return x -&gt; g x
    | DoThen act i k -&gt;
      <span class="c">//Now, we have to ensure that continuations are instances of</span>
      <span class="c">//F.( ^-&gt; )</span>
      DoThen act i (F.on <span class="k">_</span> (<span class="k">fun</span> x -&gt; bind (k x) g))

<span class="k">let</span> <span class="k">rec</span> equiv #acts #a (x y: tree acts a) =
  <span class="k">match</span> x, y <span class="k">with</span> 
  | Return vx, Return vy -&gt; vx == vy
  | DoThen actx ix kx, DoThen acty iy ky -&gt;
    actx == acty /\
    ix == iy /\
    (<span class="k">forall</span> o. equiv (kx o) (ky o))
  | <span class="k">_</span> -&gt; False

<span class="k">let</span> <span class="k">rec</span> equiv_refl #acts #a (x:tree acts a) 
  : <span class="k">Lemma</span> (equiv x x)
  = <span class="k">match</span> x <span class="k">with</span>
    | Return v -&gt; ()
    | DoThen act i k -&gt; 
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (k o) (k o)
      <span class="k">with</span> (equiv_refl (k o))

<span class="k">let</span> <span class="k">rec</span> equiv_sym #acts #a (x y:tree acts a) 
  : <span class="k">Lemma</span> 
    (<span class="k">requires</span> equiv x y)
    (<span class="k">ensures</span> equiv y x)
  = <span class="k">match</span> x, y <span class="k">with</span>
    | Return <span class="k">_</span>, Return <span class="k">_</span> -&gt; ()
    | DoThen act i kx, DoThen <span class="k">_</span> <span class="k">_</span> ky -&gt; 
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (ky o) (kx o)
      <span class="k">with</span> equiv_sym (kx o) (ky o)

<span class="k">let</span> <span class="k">rec</span> equiv_trans #acts #a (x y z: tree acts a)
  : <span class="k">Lemma</span> 
    (<span class="k">requires</span> equiv x y /\ equiv y z)
    (<span class="k">ensures</span> equiv x z)
  = <span class="k">match</span> x, y, z <span class="k">with</span>
    | Return <span class="k">_</span>, <span class="k">_</span>, <span class="k">_</span> -&gt; ()
    | DoThen act i kx, DoThen <span class="k">_</span> <span class="k">_</span> ky, DoThen <span class="k">_</span> <span class="k">_</span> kz -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. equiv (kx o) (kz o)
      <span class="k">with</span> equiv_trans (kx o) (ky o) (kz o)

<span class="c">// THIS IS THE MAIN LEMMA OF THE EXERCISE</span>
<span class="k">let</span> <span class="k">rec</span> equiv_is_equal #acts #a (x y: tree acts a)
  : <span class="k">Lemma</span>
    (<span class="k">requires</span> equiv x y)
    (<span class="k">ensures</span> x == y)
  = <span class="k">match</span> x, y <span class="k">with</span>
    | Return <span class="k">_</span>, Return <span class="k">_</span> -&gt; ()
    | DoThen act i kx, DoThen <span class="k">_</span> <span class="k">_</span> ky -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. kx o == ky o
      <span class="k">with</span> equiv_is_equal (kx o) (ky o);
      F.extensionality <span class="k">_</span> <span class="k">_</span> kx ky

<span class="k">let</span> right_identity #acts #a #b (x:a) (g:a -&gt; tree acts b)
  : <span class="k">Lemma</span> (bind (return x) g `equiv` g x)
  = equiv_refl (g x)

<span class="k">let</span> <span class="k">rec</span> left_identity #acts #a (f:tree acts a)
  : <span class="k">Lemma</span> (bind f return `equiv` f)
  = <span class="k">match</span> f <span class="k">with</span>
    | Return <span class="k">_</span> -&gt; ()
    | DoThen act i k -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. bind (k o) return `equiv` (k o)
      <span class="k">with</span> left_identity (k o)

<span class="k">let</span> <span class="k">rec</span> assoc #acts #a #b #c 
              (f1: tree acts a)
              (f2: a -&gt; tree acts b)
              (f3: b -&gt; tree acts c)
  : <span class="k">Lemma</span> (bind f1 (<span class="k">fun</span> x -&gt; bind (f2 x) f3) `equiv`
           bind (bind f1 f2) f3)
  = <span class="k">match</span> f1 <span class="k">with</span>
    | Return v -&gt; 
      right_identity v f2;
      right_identity v (<span class="k">fun</span> x -&gt; bind (f2 x) f3)
    | DoThen act i k -&gt;
      <span class="k">introduce</span> <span class="k">forall</span> o. bind (k o) (<span class="k">fun</span> x -&gt; bind (f2 x) f3) `equiv`
                     bind (bind (k o) f2) f3
      <span class="k">with</span> assoc (k o) f2 f3

<span class="k">type</span> rw =
  | Read
  | Write

<span class="k">let</span> input_of : rw -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | Read -&gt; unit
    | Write -&gt; int

<span class="k">let</span> output_of : rw -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | Read -&gt; int
    | Write -&gt; unit

<span class="k">let</span> rw_action_class = { t = rw; input_of ; output_of }

<span class="c">//Here again the continuation has to be F.( ^-&gt; )</span>
<span class="k">let</span> read : tree rw_action_class int = DoThen Read () (F.on <span class="k">_</span> Return) 
<span class="k">let</span> write (x:int) : tree rw_action_class unit = DoThen Write x (F.on <span class="k">_</span> Return)
<span class="k">let</span> read_and_increment 
  : tree rw_action_class int
  = x &lt;-- read ;
    write (x + 1);;
    return x

<span class="k">let</span> st a = int -&gt; a &amp; int
<span class="k">let</span> <span class="k">rec</span> interp #a (f: tree rw_action_class a)
  : st a 
  = <span class="k">fun</span> s0 -&gt; 
     <span class="k">match</span> f <span class="k">with</span>
     | Return x -&gt; x, s0
     | DoThen Read i k -&gt; 
       interp (k s0) s0
     | DoThen Write s1 k -&gt; 
       interp (k ()) s1

<span class="c">// And now since equivalent trees and equal, lemmas such as this</span>
<span class="c">// become trivial</span>
<span class="k">let</span> interp_equiv #a (f g:tree rw_action_class a)
  : <span class="k">Lemma</span>
    (<span class="k">requires</span> equiv f g)
    (<span class="k">ensures</span> feq (interp f) (interp g))
  = equiv_is_equal f g
</pre></div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="manipulating-computation-trees-nondeterminism-and-concurrency">
<h2>計算木の操作：非決定性と並行性<a class="headerlink" href="#manipulating-computation-trees-nondeterminism-and-concurrency" title="Link to this heading"></a></h2>
<p>最後に、計算を木で表す利点は総称性や再利用性だけではないことを示します。計算木は計算の構造を露出させるため、別の意味論でアクションを解釈する、といった操作が可能になります。</p>
<p>本節では、計算木に非決定的選択を加えます。すなわち、<code class="docutils literal notranslate"><span class="pre">l,</span> <span class="pre">r:</span> <span class="pre">tree</span> <span class="pre">acts</span> <span class="pre">a</span></code> という 2 つの計算があれば、非決定的に <code class="docutils literal notranslate"><span class="pre">l</span></code> か <code class="docutils literal notranslate"><span class="pre">r</span></code> のどちらかを評価できます。この機能により、複数スレッドの命令的動作をインタリーブする意味論など、並行性のいくつかのモデルも表現できます。</p>
<p>まず <code class="docutils literal notranslate"><span class="pre">tree</span></code> 型に <code class="docutils literal notranslate"><span class="pre">Or</span> <span class="pre">l</span> <span class="pre">r</span></code> ノードを追加し、<code class="docutils literal notranslate"><span class="pre">l</span></code> と <code class="docutils literal notranslate"><span class="pre">r</span></code> の非決定的選択を表現できるようにします。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">noeq</span>
<span class="k">type</span> tree (acts:action_class) (a:Type) =
  | Return : x:a -&gt; tree acts a
  | DoThen : act:acts.t -&gt;
             input:acts.input_of act -&gt;
             continue: (acts.output_of act -&gt; tree acts a) -&gt;
             tree acts a
  | Or :  tree acts a -&gt; tree acts a -&gt; tree acts a
</pre></div>
</div>
<p>これまで同様、<code class="docutils literal notranslate"><span class="pre">return</span></code> と <code class="docutils literal notranslate"><span class="pre">bind</span></code> を定義できます。今回は <code class="docutils literal notranslate"><span class="pre">bind</span></code> において、<code class="docutils literal notranslate"><span class="pre">Or</span></code> の両選択肢の後に <code class="docutils literal notranslate"><span class="pre">g</span></code> を続けます。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> return #acts #a (x:a)
  : tree acts a
  = Return x

<span class="k">let</span> <span class="k">rec</span> bind #acts #a #b (f: tree acts a) (g: a -&gt; tree acts b)
  : tree acts b
  = <span class="k">match</span> f <span class="k">with</span>
    | Return x -&gt; g x
    | DoThen act i k -&gt;
      DoThen act i (<span class="k">fun</span> x -&gt; bind (k x) g)
    | Or m0 m1 -&gt; Or (bind m0 g) (bind m1 g)
</pre></div>
</div>
<p>さらに興味深いのは、逐次合成に加えて、<code class="docutils literal notranslate"><span class="pre">par</span> <span class="pre">f</span> <span class="pre">g</span></code> により 2 つの計算の並列合成も定義できることです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> l_par #acts #a #b (f:tree acts a) (g:tree acts b)
  : tree acts (a &amp; b)
  = <span class="k">match</span> f <span class="k">with</span>
    | Return v -&gt; x &lt;-- g; return (v, x)
    | DoThen a i k -&gt;
      DoThen a i (<span class="k">fun</span> x -&gt; r_par (k x) g)
    | Or m0 m1 -&gt; Or (l_par m0 g) (l_par m1 g)

<span class="k">and</span> r_par #acts #a #b (f:tree acts a) (g: tree acts b)
  : tree acts (a &amp; b)
  = <span class="k">match</span> g <span class="k">with</span>
    | Return v -&gt; x &lt;-- f; return (x, v)
    | DoThen a i k -&gt;
      DoThen a i (<span class="k">fun</span> x -&gt; l_par f (k x))
    | Or m0 m1 -&gt; Or (r_par f m0) (r_par f m1)

<span class="k">let</span> par #acts #a #b (f: tree acts a) (g: tree acts b)
  : tree acts (a &amp; b)
  = Or (l_par f g) (r_par f g)
</pre></div>
</div>
<p>ここには多くの要素が含まれるため、少し分解して説明します。</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l_par</span> <span class="pre">f</span> <span class="pre">g</span></code> と <code class="docutils literal notranslate"><span class="pre">r_par</span> <span class="pre">f</span> <span class="pre">g</span></code> は相互再帰で、<code class="docutils literal notranslate"><span class="pre">f</span></code> と <code class="docutils literal notranslate"><span class="pre">g</span></code> のアクションをインタリーブする意味論を定義します。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l_par</span> <span class="pre">f</span> <span class="pre">g</span></code> は左優先で、まず <code class="docutils literal notranslate"><span class="pre">f</span></code> からアクションを選びます（残っていれば）。<code class="docutils literal notranslate"><span class="pre">r_par</span> <span class="pre">f</span> <span class="pre">g</span></code> は右優先で、まず <code class="docutils literal notranslate"><span class="pre">g</span></code> から選びます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l_par</span></code> の <code class="docutils literal notranslate"><span class="pre">DoThen</span></code> の場合を考えます。<code class="docutils literal notranslate"><span class="pre">f</span></code> から先頭のアクション <code class="docutils literal notranslate"><span class="pre">a</span></code> を選び、継続では <code class="docutils literal notranslate"><span class="pre">r_par</span> <span class="pre">(k</span> <span class="pre">x)</span> <span class="pre">g</span></code> を呼ぶことで、<code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span></code> よりも先に <code class="docutils literal notranslate"><span class="pre">g</span></code> のアクションを実行するのを優先します。<code class="docutils literal notranslate"><span class="pre">r_par</span></code> の <code class="docutils literal notranslate"><span class="pre">DoThen</span></code> は対称です。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l_par</span></code> では、非決定的選択（<code class="docutils literal notranslate"><span class="pre">Or</span></code>）のとき、<code class="docutils literal notranslate"><span class="pre">f</span></code> のどちらの分岐も <code class="docutils literal notranslate"><span class="pre">g</span></code> とインタリーブします。<code class="docutils literal notranslate"><span class="pre">r_par</span></code> も対称です。</p></li>
<li><p>最後に、並列合成 <code class="docutils literal notranslate"><span class="pre">par</span> <span class="pre">f</span> <span class="pre">g</span></code> を、左優先インタリーブと右優先インタリーブの非決定的選択として定義します。これにより、並列合成の意味論はスレッド間のラウンドロビン的なスケジューリングになりますが、他種のスケジューラを実装することも可能です。</p></li>
</ul>
</div></blockquote>
<p>前と同様、読み書き動作で木を具体化し、簡単なプログラムを書けます。例えば、カウンタを 2 回並列に増やそうとする <code class="docutils literal notranslate"><span class="pre">par_inc</span></code> などです。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> read : tree rw_actions int = DoThen Read () Return
<span class="k">let</span> write (x:int) : tree rw_actions unit = DoThen Write x Return
<span class="k">let</span> inc
  : tree rw_actions unit
  = x &lt;-- read ;
    write (x + 1)
<span class="k">let</span> par_inc = par inc inc 
</pre></div>
</div>
<p>しかし問題があります――インタリーブ意味論のため、実際には状態が 2 回増えません。</p>
<p>確認のため、計算を実行する解釈関数を定義しましょう。<code class="docutils literal notranslate"><span class="pre">Or</span></code> ノードの非決定を解消する必要があるので、インタプリタには「ランダム性」の供給源として無限のブール列を渡すことにします。</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> randomness = nat -&gt; bool
<span class="k">let</span> par_st a = randomness -&gt; pos:nat -&gt; s0:int -&gt; (a &amp; int &amp; nat)
<span class="k">let</span> <span class="k">rec</span> interp #a (f:tree rw_actions a) 
  : par_st a 
  = <span class="k">fun</span> rand pos s0 -&gt;
      <span class="k">match</span> f <span class="k">with</span>
      | Return x -&gt; x, s0, pos
      | DoThen Read <span class="k">_</span> k -&gt; interp (k s0) rand pos s0
      | DoThen Write s1 k -&gt; interp (k ()) rand pos s1      
      | Or l r -&gt; 
        <span class="k">if</span> rand pos
        <span class="k">then</span> interp l rand (pos + 1) s0
        <span class="k">else</span> interp r rand (pos + 1) s0
<span class="k">let</span> st a = int -&gt; a &amp; int
<span class="k">let</span> interpret #a (f:tree rw_actions a) 
  : st a    
  = <span class="k">fun</span> s0 -&gt; 
      <span class="k">let</span> x, s, <span class="k">_</span> = interp f (<span class="k">fun</span> n -&gt; n % 2 = 0) 0 s0 <span class="k">in</span> 
      x, s
</pre></div>
</div>
<p>このインタプリタは以前のものとよく似ていますが、<code class="docutils literal notranslate"><span class="pre">Or</span></code> の場合だけ <a href="#id1"><span class="problematic" id="id2">``</span></a>rand``（乱数ストリーム）からブール値を 1 つ読み取り、左枝か右枝かを選びます。</p>
<p>このインタプリタでプログラムを実行し、結果を確認できます。1 つの方法は、F* の正規化器（型検査中に計算を簡約する抽象機械）を利用することです。以下で使う <code class="docutils literal notranslate"><span class="pre">assert_norm</span> <span class="pre">p</span></code> は、項 <code class="docutils literal notranslate"><span class="pre">p</span></code> を可能な限り記号的に簡約し、その結果が <code class="docutils literal notranslate"><span class="pre">True</span></code> と同値であるかを検査する機能です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>F* の Emacs モード <code class="docutils literal notranslate"><span class="pre">fstar-mode.el</span></code> には、抽象機械で項を簡約し結果を表示するユーティリティがあります。また、F* のタクティクスでも項の評価と結果の確認が可能です――これらの機能の詳細は後の章に譲ります。</p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> test_prog = <span class="k">assert_norm</span> (<span class="k">forall</span> x. snd (interpret par_inc x) == x + 1)
</pre></div>
</div>
<p>この例では、定義したインタプリタで <code class="docutils literal notranslate"><span class="pre">par_inc</span></code> を解釈するよう F* に指示します。すると、最終状態では 1 回しかインクリメントされていないことが確認されます。ラウンドロビンのスケジューリングのため、両方の読み取りが書き込みより先に実行され、その結果、1 回分の読み取りと書き込みが無駄になったのです。</p>
<section id="id4">
<h3>練習問題<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>読み書きに加えてインクリメント操作を含むアクションクラスを定義しなさい。上のインタプリタをこのアクションクラスで動くように修正し、（<code class="docutils literal notranslate"><span class="pre">assert_norm</span></code> を用いて）2 つの原子的インクリメントを並列に含むプログラムが状態を 2 回増やすことを証明しなさい。</p>
<p><a class="reference external" href="../code/exercises/Part2.AtomicIncrement.fst">演習ファイル</a></p>
<div class="toggle docutils container">
<div class="header docutils container">
<p><strong>解答</strong></p>
</div>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> rwi =
  | R
  | W
  | Inc
  
<span class="k">let</span> input_of_rwi : rwi -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | R -&gt; unit
    | W -&gt; int
    | Inc -&gt; unit

<span class="k">let</span> output_of_rwi : rwi -&gt; Type =
  <span class="k">fun</span> a -&gt;
    <span class="k">match</span> a <span class="k">with</span>
    | R -&gt; int
    | W -&gt; unit
    | Inc -&gt; unit

<span class="k">let</span> rwi_actions = { t = rwi; input_of=input_of_rwi ; output_of=output_of_rwi }

<span class="k">let</span> atomic_inc : tree rwi_actions unit = DoThen Inc () Return

<span class="k">let</span> <span class="k">rec</span> interp_rwi #a (f:tree rwi_actions a) 
  : par_st a 
  = <span class="k">fun</span> tape pos s0 -&gt;
      <span class="k">match</span> f <span class="k">with</span>
      | Return x -&gt; x, s0, pos
      | DoThen R <span class="k">_</span> k -&gt; interp_rwi (k s0) tape pos s0
      | DoThen W s1 k -&gt; interp_rwi (k ()) tape pos s1      
      | DoThen Inc () k -&gt; interp_rwi (k ()) tape pos (s0 + 1)            
      | Or l r -&gt; 
        <span class="k">let</span> b = tape pos <span class="k">in</span>
        <span class="k">if</span> b
        <span class="k">then</span> interp_rwi l tape (pos + 1) s0
        <span class="k">else</span> interp_rwi r tape (pos + 1) s0
<span class="k">let</span> interpret_rwi #a (f:tree rwi_actions a) 
  : st a    
  = <span class="k">fun</span> s0 -&gt; 
      <span class="k">let</span> x, s, <span class="k">_</span> = interp_rwi f (<span class="k">fun</span> n -&gt; n % 2 = 0) 0 s0 <span class="k">in</span> 
      x, s

<span class="k">let</span> par_atomic_inc = par atomic_inc atomic_inc
<span class="k">let</span> test_par_atomic_inc = <span class="k">assert_norm</span> (<span class="k">forall</span> x. snd (interpret_rwi par_atomic_inc x) == x + 2)
</pre></div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="looking-ahead">
<h2>今後に向けて<a class="headerlink" href="#looking-ahead" title="Link to this heading"></a></h2>
<p>副作用を伴う正しいプログラムを書くのは難しく、とりわけ可変状態や並行性が絡むとなおさらです！</p>
<p>ここで見たように、これらのプログラムの意味論はモデル化できても、正しく動作することの証明は容易ではありません。また、インタプリタを定義してはいるものの、効率は程遠いものです。実用上は性能のため共有メモリ並行性などに頼るのが一般的で、我々のインタプリタは数学的には厳密でも、実行速度は悲惨です。</p>
<p>これら 2 つの課題に対処するのが、F* のユーザ定義効果システムの主目的であり、言語の大きな柱です。詳細は後の節で扱います。効果システムは主に次のニーズに応えます。</p>
<blockquote>
<div><ul class="simple">
<li><p>効果付きプログラムの証明：効果システムは、プログラム特性の記述と証明を可能にする <em>プログラム論理</em> と結びついた効果付きプログラムの開発を可能にします。F* ライブラリが提供する多様な論理――逐次プログラム向けの古典的 Floyd–Hoare 論理、プログラム同値の関係論理、最弱事前条件計算、並行・分散プログラム向けの分離論理――を学びます。</p></li>
<li><p>効果の抽象化：プログラムはきれいな数学的意味論に対して仕様化・証明できますが、効率的な実行のために、F* は効果の表現を隠蔽する仕組みを提供します。これにより、状態・例外・並行性・IO などの効果をネイティブにサポートする形で、効果付きプログラムを効率よくコンパイルできます。</p></li>
</ul>
</div></blockquote>
</section>
</section>


           </div>
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="part2_well_founded.html" class="btn btn-neutral float-left" title="良基底関係と停止性" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="part2_universes.html" class="btn btn-neutral float-right" title="ユニバース（Universes）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Microsoft Research.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>